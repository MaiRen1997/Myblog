## Vue的优点？Vue的缺点？

优点：渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开

缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长

## 为什么说Vue是一个渐进式框架？

渐进式：通俗点讲就是，你想用啥你就用啥，咱也不强求你。你想用component就用，不用也行，你想用vuex就用，不用也可以

![image.png](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic/vueImg/202401230958197.webp)

## Vue跟React的异同点？

相同点：

- 1.都使用了虚拟dom
- 2.组件化开发
- 3.都是单向数据流(父子组件之间，不建议子修改父传下来的数据)
- 4.都支持服务端渲染 不同点：
- 1.React的JSX，Vue的template
- 2.数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty)
- 3.React单向绑定，Vue双向绑定
- 4.React的Redux，Vue的Vuex

## MVVM是什么？和MVC有何区别呢？

### MVC

- Model(模型)：负责从数据库中取数据
- View(视图)：负责展示数据的地方
- Controller(控制器)：用户交互的地方，例如点击事件等等
- 思想：Controller将Model的数据展示在View上

![image.png](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic/vueImg/202401230959089.webp)

### MVVM

- VM：也就是View-Model，做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。

- 思想：实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思

  ![image.png](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic/vueImg/202401230959695.webp)

区别

整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性

Vue是不是MVVM框架？

Vue是MVVM框架，但是不是严格符合MVVM，因为MVVM规定Model和View不能直接通信，而Vue的`ref`可以做到这点

## Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？

1. jQuery是直接操作DOM，Vue不直接操作DOM，Vue的数据与视图是分开的，Vue只需要操作数据即可
2. 在操作DOM频繁的场景里，jQuery的操作DOM行为是频繁的，而Vue利用虚拟DOM的技术，大大提高了更新DOM时的性能
3. Vue中不倡导直接操作DOM，开发者只需要把大部分精力放在数据层面上
4. Vue集成的一些库，大大提高开发效率，比如Vuex，Router等

## 为什么data是个函数并且返回一个对象呢？

`data`之所以是一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行`data函数`并返回新的数据对象，这样，可以避免多处调用之间的`数据污染`

## 使用过哪些Vue的修饰符呢？

![截屏2021-07-11 下午9.56.53.png](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic/vueImg/202401231056809.webp)

## 使用过哪些Vue的内部指令呢？

![image.png](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic/vueImg/202401231056505.webp)

## 组件之间的传值方式有哪些？

### 父传子

1. 父组件传值给子组件，子组件使用`props`进行接收
2. 组件中可以使用`$parent`，获取到父组件实例，进而获取数据
3. 使用`$refs`获取组件实例，进而获取数据

### 子传父

1. 子组件传值给父组件，子组件使用`$emit+事件`对父组件进行传值
2. 组件中可以使用`$children`获取到子组件实例，进而获取数据
3. 使用`$attrs`和`$listeners`，在对一些组件进行二次封装时可以方便传值，例如A->B->C
4. 使用`eventBus`进行跨组件触发事件，进而传递数据
5. 使用`provide`和`inject`，官方建议我们不要用这个，我在看`ElementUI`源码时发现大量使用

### 全局

1. 使用`Vuex`进行状态管理
2. 使用浏览器本地缓存，例如`localStorage`

## 路由有哪些模式呢？又有什么不同呢？

- hash模式：通过`#号`后面的内容的更改，触发`hashchange`事件，实现路由切换
- history模式：通过`pushState`和`replaceState`切换url，实现路由切换，需要后端配合

## 如何设置动态class，动态style？

动态class对象：`<div :class="{ 'is-active': true, 'red': isRed }"></div>`

动态class数组：`<div :class="['is-active', isRed ? 'red' : '' ]"></div>`

动态style对象：`<div :style="{ color: textColor, fontSize: '18px' }"></div>`

动态style数组：`<div :style="[{ color: textColor, fontSize: '18px' }, { fontWeight: '300' }]"></div>`

## v-if和v-show有何区别？

1. `v-if`是通过控制dom元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁
2. `v-show`是通过控制dom元素的css样式来实现显隐，不会销毁
3. 频繁或者大数量显隐使用`v-show`，否则使用`v-if`

## computed和watch有何区别？

1. `computed`是依赖已有的变量来计算一个目标变量，大多数情况都是`多个变量`凑在一起计算出`一个变量`，并且`computed`具有`缓存机制`，依赖值不变的情况下其会直接读取缓存进行复用，`computed`不能进行`异步操作`
2. `watch`是监听某一个变量的变化，并执行相应的回调函数，通常是`一个变量`的变化决定`多个变量`的变化，`watch`可以进行`异步操作`
3. 简单记就是：一般情况下`computed`是`多对一`，`watch`是`一对多`

## 为什么v-if和v-for不建议用在同一标签？

在Vue2中，`v-for`优先级是高于`v-if`的，咱们来看例子

```js
<div v-for="item in [1, 2, 3, 4, 5, 6, 7]" v-if="item !== 3">
    {{item}}
</div>
```

上面的写法是`v-for`和`v-if`同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：

```js
<div v-for="item in list">
    {{item}}
</div>

computed() {
    list() {
        return [1, 2, 3, 4, 5, 6, 7].filter(item => item !== 3)
    }
  }
```

## vuex的有哪些属性？用处是什么？

![image.png](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic/vueImg/202401231103282.webp)

1. State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
2. Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
3. Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
4. Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

## 不需要响应式的数据应该怎么处理？

在我们的Vue开发中，会有一些数据，从始至终都`未曾改变过`，这种`死数据`，既然`不改变`，那也就`不需要对他做响应式处理`了，不然只会做一些无用功消耗性能，比如一些写死的下拉框，写死的表格数据，这些数据量大的`死数据`，如果都进行响应式处理，那会消耗大量性能。

```js
js复制代码// 方法一：将数据定义在data之外
data () {
    this.list1 = { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx }
    this.list2 = { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx }
    this.list3 = { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx }
    this.list4 = { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx }
    this.list5 = { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx }
    return {}
 }
    
// 方法二：Object.freeze()
data () {
    return {
        list1: Object.freeze({xxxxxxxxxxxxxxxxxxxxxxxx}),
        list2: Object.freeze({xxxxxxxxxxxxxxxxxxxxxxxx}),
        list3: Object.freeze({xxxxxxxxxxxxxxxxxxxxxxxx}),
        list4: Object.freeze({xxxxxxxxxxxxxxxxxxxxxxxx}),
        list5: Object.freeze({xxxxxxxxxxxxxxxxxxxxxxxx}),
    }
}
```

## watch的写法

### 当我们监听一个基本数据类型时：

```js
js复制代码watch: {
    value () {
        // do something
    }
}
```

### 当我们监听一个引用数据类型时：

```js
js复制代码watch: {
    obj: {
       handler () { // 执行回调
           // do something
       },
       deep: true, // 是否进行深度监听
       immediate: true // 是否初始执行handler函数
    }
}
```

## 父子组件生命周期顺序

父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

## 对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？

原因：`Object.defineProperty`没有对对象的新属性进行属性劫持

对象新属性无法更新视图：使用`Vue.$set(obj, key, value)`，组件中`this.$set(obj, key, value)`

删除属性无法更新视图：使用`Vue.$delete(obj, key)`，组件中`this.$delete(obj, key)`











































