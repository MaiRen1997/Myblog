---
title: ES6(2015)基础笔记
date: 2023-12-18 21:55:15
author:
  name: Riverside Joy
  link: https://github.com/MaiRen1997
permalink: /pages/d5f121/
categories:
  - 前端
  - javaScript基础
tags:
  - 
---
[文件参考链接](http://es.xiecheng.live/introduction/preface.html)

## 可选链运算符

**可选链运算符**（**`?.`**）允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。`?.` 运算符的功能类似于 `.` 链式运算符，不同之处在于，在引用为空 (`nullish`) (`null`) 或者 `undefined`) 的情况下不会引起错误，该表达式短路返回值是 `undefined`。与函数调用一起使用时，如果给定的函数不存在，则返回 `undefined`

### 使用讲解

以前需要递归查找属性是否存在

```js
let nestedProp = obj.first && obj.first.second;
```

现在可以直接使用

```js
let nestedProp = obj.first?.second;
```

:::tip

通过使用 `?.` 运算符取代 `.` 运算符，JavaScript 会在尝试访问 `obj.first.second` 之前，先隐式地检查并确定 `obj.first` 既不是 `null` 也不是 `undefined`。如果`obj.first` 是 `null` 或者 `undefined`，表达式将会短路计算直接返回 `undefined`

:::

### 连续使用

```js
let customer = {
  name: "Carl",
  details: {
    age: 82,
    location: "Paradise Falls", // details 的 address 属性未有定义
  },
};
let customerCity = customer.details?.address?.city;

// … 可选链也可以和函数调用一起使用
let duration = vacations.trip?.getTime?.();
```

### 使用空值合并运算符

```js
let customer = {
  name: "Carl",
  details: { age: 82 },
};
let customerCity = customer?.city ?? "暗之城";
console.log(customerCity); // “暗之城”
```

## delete运算符

**`delete`** 运算符用于删除对象的一个属性；如果该属性的值是一个对象，并且没有更多对该对象的引用，该属性所持有的对象最终会自动释放

### 基础语法

```js
const Employee = {
  firstname: 'Maria',
  lastname: 'Sanchez',
};

console.log(Employee.firstname);
// Expected output: "Maria"

delete Employee.firstname;

console.log(Employee.firstname);
// Expected output: undefined
```

```js
// 在全局作用域创建 empCount 属性
// 因为我们使用了 var，它会标记为不可配置
var empCount = 43;

// 在全局作用域创建 adminName 属性
// 因为没有使用 var，它会标记为可配置
adminName = "xyz";

EmployeeDetails = {
  name: "xyz",
  age: 5,
  designation: "Developer",
};

// delete 可用于删除对象的属性
delete EmployeeDetails.name; // 返回 true

// 甚至属性不存在，它也会返回 "true"
delete EmployeeDetails.salary; // 返回 true

// EmployeeDetails 是全局作用域的一个属性。
delete EmployeeDetails; // 返回 true

// 相反，empCount 是不可配置的，
// 因为创建它时使用了 var。
delete empCount; // 返回 false

// adminName 是全局作用域的一个属性。
// 因为它不是用 var 创建的，所以可以删除。
// 因此，它是可配置的。
delete adminName; // 返回 true

// delete 对内建静态属性不起作用
// 这些属性是不可配置的
delete Math.PI; // 返回 false

function f() {
  var z = 44;

  // delete 对局部变量名不起作用
  delete z; // 返回 false
}
```

## 解构赋值

### 解构数组

#### 赋值默认值

```js
const [a = 1] = []; // a is 1
const { b = 2 } = { b: undefined }; // b is 2
const { c = 2 } = { c: null }; // c is null
```

#### 剩余属性

```js
[a, b, ...rest] = [10, 20, 30, 40, 50];

console.log(rest);
// Expected output: Array [30, 40, 50]
```

::tip

如果使用如下代码

```js
const arr = [10, 20, 30, 40, 50];
[a,b,...rest] = arr
```

是会报错

此处在定义时，需要使用let关键字进行定义

:::

#### 解构比源更多的元素

在从赋值语句右侧指定的长度为 *N* 的数组解构的数组中，如果赋值语句左侧指定的变量数量大于 *N*，则只有前 *N* 个变量被赋值。其余变量的值将是未定义

```js
const foo = ["one", "two"];

const [red, yellow, green, blue] = foo;
console.log(red); // "one"
console.log(yellow); // "two"
console.log(green); // undefined
console.log(blue); //undefined
```

#### 交换变量

可以在一个解构表达式中交换两个变量的值。

没有解构赋值的情况下，交换两个变量需要一个临时变量

```js
let a = 1;
let b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1

const arr = [1, 2, 3];
[arr[2], arr[1]] = [arr[1], arr[2]];
console.log(arr); // [1, 3, 2]
```

#### 忽略某些返回值

```js
function f() {
  return [1, 2, 3];
}

const [a, , b] = f();
console.log(a); // 1
console.log(b); // 3

const [c] = f();
console.log(c); // 1
```

### 解构对象

#### 基本赋值

```js
const user = {
  id: 42,
  isVerified: true,
};

const { id, isVerified } = user;

console.log(id); // 42
console.log(isVerified); // true
```

#### 赋值给新的变量名

```js
const o = { p: 42, q: true };
const { p: foo, q: bar } = o;

console.log(foo); // 42
console.log(bar); // true
```

#### 赋值到新的变量名并提供默认值

一个属性可以同时是两者：

- 从对象提取并分配给具有不同名称的变量。
- 指定一个默认值，以防获取的值为 `undefined`。

```js
const { a: aa = 10, b: bb = 5 } = { a: 3 };

console.log(aa); // 3
console.log(bb); // 5
```

#### 函数参数传递的对象中提取属性

传递给函数参数的对象也可以提取到变量中，然后可以在函数体内访问这些变量。至于对象赋值，解构语法允许新变量具有与原始属性相同或不同的名称，并为原始对象未定义属性的情况分配默认值。

请考虑此对象，其中包含有关用户的信息。

```js
const user = {
  id: 42,
  displayName: "jdoe",
  fullName: {
    firstName: "Jane",
    lastName: "Doe",
  },
};

function userId({ id }) {
  return id;
}

console.log(userId(user)); // 42
```

你可以定义提取变量的名称。在这里，我们提取名为 `displayName` 的属性，并将其重命名为 `dname`，以便在函数体内使用

```js
function userDisplayName({ displayName: dname }) {
  return dname;
}

console.log(userDisplayName(user)); // `jdoe`
```

#### 解构嵌套对象和数组

```js
const metadata = {
  title: "Scratchpad",
  translations: [
    {
      locale: "de",
      localization_tags: [],
      last_edit: "2014-04-14T08:43:37",
      url: "/de/docs/Tools/Scratchpad",
      title: "JavaScript-Umgebung",
    },
  ],
  url: "/zh-CN/docs/Tools/Scratchpad",
};

let {
  title: englishTitle, // rename
  translations: [
    {
      title: localeTitle, // rename
    },
  ],
} = metadata;

console.log(englishTitle); // "Scratchpad"
console.log(localeTitle); // "JavaScript-Umgebung"
```



## 逻辑空赋值??=

逻辑空赋值运算符（`x ??= y`）仅在 `x` 是`空值`（`null` 或 `undefined`）时对其赋值

```js
const a = { duration: 50 };

a.duration ??= 10;
console.log(a.duration);
// Expected output: 50

a.speed ??= 25;
console.log(a.speed);
// Expected output: 25
```

## 空值合并运算符??

**空值合并运算符**（**`??`**）是一个逻辑运算符，当左侧的操作数为 `null`或者 `undefined` 时，返回其右侧操作数，否则返回左侧操作数

与逻辑或运算符（`||`）不同，逻辑或运算符会在左侧操作数为**`假值`**时返回右侧操作数。也就是说，如果使用 `||` 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，`''` 或 `0`）时。见下面的例子

```js
const foo = null ?? 'default string';
console.log(foo);
// Expected output: "default string"

const baz = 0 ?? 42;
console.log(baz);
// Expected output: 0
```

```js
const nullValue = null;
const emptyText = ""; // 空字符串，是一个假值，Boolean("") === false
const someNumber = 42;

const valA = nullValue ?? "valA 的默认值";
const valB = emptyText ?? "valB 的默认值";
const valC = someNumber ?? 0;

console.log(valA); // "valA 的默认值"
console.log(valB); // ""（空字符串虽然是假值，但不是 null 或者 undefined）
console.log(valC); // 42
```

:::tip ??=与?? 的区别

??=可以自动赋值

??只能判断是否是null或者undefined ，不能自动赋值

类似与+，+=的逻辑

:::

## 属性访问器

属性访问器提供了两种方式用于访问一个对象的属性，它们分别是`点号`和`方括号`

```js
const person1 = {};
person1['firstname'] = 'Mario';
person1['lastname'] = 'Rossi';

console.log(person1.firstname);
// Expected output: "Mario"

const person2 = {
  firstname: 'John',
  lastname: 'Doe',
};

console.log(person2['lastname']);
// Expected output: "Doe"
```



# 声明方式

## 作用域

### 分类

| 对象          | 类型                   |
| ------------- | ---------------------- |
| global/window | 全局作用域             |
| function      | 函数作用域(局部作用域) |
| {}            | 块状作用域             |
| this          | 动态作用域             |

> - 如果一个 `变量 或者其他表达式不在 "当前的作用域"`，那么JavaScript机制会继续`沿着作用域链向上`查找`直到全局作用域`（global或浏览器中的window）如果`找不到将不可被使用`
>
> - 子作用域可以访问父作用域
> - 父作用域不可以访问子作用域

### 全局作用域

- 变量在`函数或者代码块外定义`，即为全局作用域

- 变量在函数或代码块内定义，但是不使用声明关键字(不使用let、var、const等)

  ```js
  window.onload = function() {
      var count = 10   // 全局作用域
      console.log(count);
      function testFunction() {
        test = 'test'  // 不使用关键字定义，全局作用域(但是要记得调用函数)
      }
      testFunction()
      console.log(test);
    }
  ```

  > 没有使用 var 定义的变量虽然拥有全局作用域，但是它是可以被 delete 的，而全局变量不可以

### 函数作用域

在函数内部定义的变量，就是局部作用域。函数作用域内，对外是封闭的，从外层的作用域无法直接访问函数内部的作用域！

```js
function bar() {
    var testValue = 'inner'
}

console.log(testValue) // 报错：ReferenceError: testValue is not defined
```

如果想读取函数内的变量,必须借助 return 或者闭包.

1. return方式

   ```js
   function bar(value) {
       var testValue = 'inner'
   
       return testValue + value
   }
   
   console.log(bar('fun')) // "innerfun"
   ```

2. 闭包方式

   ```js
   function bar(value) {
       var testValue = 'inner'
   
       var rusult = testValue + value
   
       function innser() {
           return rusult
       }
   
       return innser()
   }
   
   console.log(bar('fun')) // "innerfun"
   ```

### 块状作用域

大括号里面的，称为块状作用域,比如if后面的大括号，就是一个块状作用域

```js
if (true) {
    let a = 1
    console.log(a)
}
```

### 动态作用域

通过call、apply、bind进行动态改变this指向

#### 使用call函数

`call()` 函数可以将一个对象作为第一个参数传递给一个函数，并将这个对象设置为函数的 `this` 值，然后执行函数

`call为立即执行函数`

```js
function.call(thisArg, arg1, arg2, ...)
```

#### 使用apply函数

`apply为立即执行函数`

#### 使用bind函数

`bind为非立即执行函数`

### this的指向

1. 普通函数中，指向调用者
2. 构造函数中，指向实例
3. 全局函数中，指向window
4. 原型函数中，指向调用者
5. 自执行函数中，指向window
6. 计时器中，指向window
7. 严格模式中，不指向window
8. 箭头函数中指向父级对象

## 闭包

### 闭包形成的三个条件

1. 函数嵌套

2. 在内层函数中，引用外层函数的变量或参数

3. 内层函数被作为返回值返回

   ```js
   function init() {
     var name = "Mozilla"; // name 是一个被 init 创建的局部变量
     function displayName() {
       // displayName() 是内部函数，一个闭包
       alert(name); // 使用了父函数中声明的变量
     }
     displayName();
   }
   init();
   ```

### 闭包的作用

1. 隔离作用域，避免作用域污染(替代方案  自执行函数)
2. 保护具有共享意义的变量，提供相关的操作或访问接口(替代方案)

### 闭包的缺点

1. 概念复杂不容易理解
2. 占用过多的系统资源(栈内存)，大量使用闭包，会造成栈溢出

### 容易造成栈溢出的几种操作

1. 使用过多的闭包
2. 使用过多的递归
3. 使用深层嵌套的for循环



## let及特点

ES6新增let命令，用于声明变量

> 使用let声明的变量：
>
> - 不属于顶层对象window
> - 不允许重复声明
> - 不存在变量提升
> - 暂时性死区(在代码块内，使用let和const命令声明变量之前，该变量都是不可用的，语法上被称为`暂时性死区`,如果在声明之前去访问该变量，会抛出Referenct Error错误，但是var会变量提升，所以会返回undefined)
> - 块级作用域

### let声明的全局变量不是window属性

- let声明的变量，不可以通过window.变量名的方式访问

- var声明的变量，可以通过window.变量名方式访问

  ```js
  var a = 5
  console.log(window.a) // 5
  let a = 5
  console.log(window.a) // undefined
  ```

### let定义变量不允许重复声明

使用 `var 可以重复定义`，使用 `let 却不可以`

```js
var a = 5
var a = 6
console.log(a) // 6


let a = 5
let a = 6
// VM131:1 Uncaught SyntaxError: Identifier 'a' has already been declared
//   at <anonymous>:1:1
```

### let声明的变量不存在变量提升

```js
function foo() {
    console.log(a)
    var a = 5
}

foo() //undefined
```

上述代码中， `a` 的调用在声明之前，所以它的值是 undefined，而不是 Uncaught ReferenceError。实际上因为 var 会导致变量提升

对于 let 而言，变量的调用是不能先于声明的

```js
function foo() {
    console.log(a)
    let a = 5
}

foo()
// Uncaught ReferenceError: Cannot access 'a' before initialization
```

在这个代码中， `a` 的调用是在声明之前，因为 let 没有发生变量提升，所有读取 a 的时候，并没有找到，而在调用之后才找到 let 对 `a` 的定义，所以按照 tc39 的定义会报错

### let声明的变量具有暂时性死区

只要块级作用域内存在 `let` 命令，它所声明的变量就绑定在了这个区域，不再受外部的影响

```js
var a = 5
if (true) {
    a = 6
    let a
}
// Uncaught ReferenceError: Cannot access 'a' before initialization
```

上面代码中，存在全局变量 `a` ，但是块级作用域内 `let` 又声明了一个局部变量 `a` ，导致后者绑定这个块级作用域，所以在let声明变量前，对 `a` 赋值会报错。

ES6 明确规定，如果区块中存在 `let` 和 `const` 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

总之，在代码块内，使用 `let` 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”

有时“暂时性死区”比较隐蔽，比如：

```js
function foo(b = a, a = 2) {
    console.log(a, b)
}
foo()
// Uncaught ReferenceError: Cannot access 'a' before initialization
```

### let 声明的变量拥有块级作用域

let实际上为 JavaScript 新增了块级作用域

```js
{
    let a = 5
}
console.log(a) // undefined
```

`a` 变量是在代码块 `{}` 中使用 let 定义的，它的作用域是这个代码块内部，外部无法访问。

我们再看一个项目中很常见的 `for` 循环:

```js
for (var i = 0; i < 3; i++) {
    console.log('循环内:' + i) // 0、1、2
}
console.log('循环外:' + i) // 3
```

如果改为 `let` 会怎么样呢？

```js
for (let i = 0; i < 3; i++) {
    console.log('循环内:' + i) // 0、1、2
}
console.log('循环外:' + i) // ReferenceError: i is not defined
```

继续看下面两个例子的对比，这时 `a` 的值又是多少呢？

```js
if (false) {
    var a = 5
}
console.log(a) // undefined
```

```js
if (false) {
    let a = 5
}
console.log(a)
// Uncaught ReferenceError: a is not defined
```

### 思考

请问 `i` 的值是多少？

```js
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i)
    })
}
// 3、3、3
```

答案是3次3。
但我希望的值是0、1、2，也就是每次保存住循环时候 `i` 的值，应该如何做呢？

方案1：闭包

```js
for (var i = 0; i < 3; i++) {
    (function(j) {
        setTimeout(function() {
            console.log(j)
        })
    })(i)
}
```

方案2：使用let

```js
for (let i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i)
    })
}
```

大家可以把上面这段代码粘贴到 `babel` 中：https://www.babeljs.cn/repl , 看下经过 `babel` 转化为的 `ES5` 代码是什么样子的。

大家会发现其实 `babel` 把这段代码转化成了闭包的形式:

```js
"use strict"

var _loop = function _loop(i) {
    setTimeout(function() {
        console.log(i)
    })
}

for (var i = 0; i < 3; i++) {
    _loop(i)
}
```

相信通过这个思考题，大家对于 `let` 关键字的使用会有进一步的理解。

## const 

> 声明特点：
>
> 1. 不属于顶层对象window
> 2. 不允许重复声明
> 3. 不存在变量提升
> 4. 暂时性死区
> 5. 块级作用域
>
> 功能
>
> 1. 基本类型，声明后不允许修改
> 2. 复杂类型，声明后可以修改属性值，但是不能修改变量地址
> 3. 使用freeze()，进行属性冻结

### const定义常量

不能被改变的叫做常量，请大家思考在 `ES5` 中如何定义一个常量呢？

`ES5` 中可以使用 `Object.defineProperty()` 来实现定义常量：

```js
Object.defineProperty(window, 'PI', {
    value: 3.14,
    writable: false
})
console.log(PI)
PI = 5
console.log(PI)
```

`const` 除了具有 `let` 的块级作用域和不会变量提升外，还有就是它定义的是常量，在用 `const` 定义变量后，我们就不能修改它了，对变量的修改会抛出异常。

```js
const PI = 3.1415

console.log(PI)

PI = 5

console.log(PI)
// Uncaught TypeError: Assignment to constant variable.
```

这个代码块中因为对 `PI` 尝试修改，导致浏览器报错，这就说明 const 定义的变量是不能被修改的，它是只读的。聪明的同学一定会发现只读属性是不是一定要进行初始化呢？

```js
const PI

PI = 3.1415
// Uncaught SyntaxError: Missing initializer in const declaration
```

> 注意
>
> const 声明的变量必须进行初始化，不然会抛出异常 Uncaught SyntaxError: Missing initializer in const declaration。

### const定义复杂变量，可改变属性

```js
const obj = {
    name: 'xiecheng',
    age: 34
}
obj.school = 'imooc'
console.log(obj)
// {name: "xiecheng", age: 34, school: "imooc"}
```

大家会发现 `const` 定义的 `obj` 竟然被改变了... 这到底是为什么呢？有点懵啊...

这时我们就需要了解JS中的变量是如何存储的，见下图：

![img](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic@master/javaImg/stack-heap.a163c957.png)

基本数据类型存储在 `栈内存` 中，引用数据类型存储在 `堆内存` 中然后在栈内存中保存 `引用地址` 。

> TIP
>
> `const` 实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。

### freeze的使用

如何让对象或者数组这种引用数据类型也不被改变呢？

```js
Object.freeze(obj)
```

> 注意
>
> `Object.freeze()` 只是浅层冻结，只会对最近一层的对象进行冻结，并不会对深层对象冻结。

### Object.defineProperty的使用

**Object.defineproperty 的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性**

**Object.defineproperty(obj, prop, desc)**

> - obj : 第一个参数就是要在哪个对象身上添加或者修改属性
> - prop : 第二个参数就是添加或修改的属性名
> - desc ： 配置项，一般是一个对象

第三个参数里面还有6个配置控住属性

> - writable：	是否可重写
> - ​    value：  	当前值
> - ​    get：    	 读取时内部调用的函数
> - ​	set：        写入时内部调用的函数
> - ​	enumerable： 	是否可以遍历
> - ​	configurable： 	是否可再次修改配置项

## 检测数据类型的方法

### Object.prototype.toString

语法：Object.prototype.toString.call([value])
        获取Object.portotype上的toString方法，让方法的this变为需要检测的数据类型值，并且让这个方法执行

在Number、String、Boolean、Array、Function、RegExp…这些类的原型上都有一个toString方法：这个方法就是把本身的值转化为字符串

```js
Object.prototype.toString.call([]).slice(8, -1)
```

### typeof

语法：typeof 后面加不加括号都是可以用的
注意：`正则、{}、[]、null`输出`结果为object`

```js
console.log(typeof /\d/);//object
console.log(typeof {});//object
console.log(typeof []);//object
console.log(typeof (null));//object
console.log(typeof 123);//number
console.log(typeof true);//boolean
console.log(typeof function () {});//function
console.log(typeof (undefined));//undefined
```

### instanceof

> 双目运算符 a instanceof b ,判断a的构造器是否为b，返回值为布尔值

```js
function b(){}
let a = new b;
console.log(a instanceof b);//true
console.log(b instanceof Object);//true
let arr = [1,2,3,4];
console.log(arr instanceof Array);//true
```

### constructor

语法：实例.constructor
        对象的原型链下（构造函数的原型下）有一个属性，叫constructor
缺点：**constructor并不可靠，容易被修改（只有参考价值）。即使被修改了，也不会影响代码的正常运行。正常开发的时候，constructor不小心被修改了，为了方便维护，和开发，可以手动更正constructor的指向。

```js
function a() {}
let a = new b;
console.log(a.constructor.name);//a
console.log(b.constructor);//Function（）{}
console.log(Function.constructor);//Function（）{}
```

### hasOwnproperty

> 语法: obj.hasOwnporperty(“属性名（K值）”)

```js
let obj = {
	name:"lxw"
	};
	console.log(obj.hasOwnProperty('name'));//true
	console.log(obj.hasOwnProperty('lxw'));//false
```

### isArray

```js
console.log(Array.isArray([]));//true
console.log(Array.isArray(new Array()));//true
```

### valueOf

可以看到数据最本质内容（原始值）

```js
let a = "12345";
let b= new String('12345');
console.log(typeof a);//string
console.log(typeof b);//object
console.log(a == b);//true  （typeof检测出来是对象居然和一个数组相等，显然b并不是一个真的对象。）
//此时看看 valueOf()的表现
console.log(b.valueOf());//12345  拿到b的原始值是 字符串的12345
console.log(typeof b.valueOf())//string  这才是 b的真正的数据类型
```

# 浏览器适配



# 键鼠事件

## 鼠标事件

| 事件名称         | 方法          | 备注                                                         |
| ---------------- | ------------- | ------------------------------------------------------------ |
| 鼠标左键双击     | ondblclick    |                                                              |
| 鼠标悬停         | onmouseover   |                                                              |
| 鼠标移出         | onmouseout    |                                                              |
| 鼠标进入         | onmouseenter  | 如果div上面叠加了元素<br/>当鼠标移动到叠加的元素上，<br/>mouseover就失效了，然后重新触发了mouseover |
| 鼠标离开         | onmouseleave  |                                                              |
| 鼠标移动         | onmousemove   |                                                              |
| 鼠标按下         | onmousedown   |                                                              |
| 鼠标弹起         | onmouseup     |                                                              |
| 鼠标右键点击事件 | oncentextmenu |                                                              |

> 注意：以上事件中，this在事件函数中，指向的是事件对象

## 键盘事件

| 事件名称 | 方法    | 备注 |
| -------- | ------- | ---- |
| 键盘按下 | keydown |      |
| 键盘弹起 | keyup   |      |

## 表单事件

| 事件名称       | 方法     | 备注                                                   |
| -------------- | -------- | ------------------------------------------------------ |
| 获得焦点       | onfocus  |                                                        |
| 失去焦点       | onblur   |                                                        |
| 输入框输入事件 | oninput  | 当用户输入时触发                                       |
| 表单改变事件   | onchange | 该事件需要两个条件触发<br />内容发生改变<br />失去焦点 |

# 解构赋值

在 ES6 中新增了变量赋值的方式：解构赋值。允许按照一定模式，从数组和对象中提取值，对变量进行赋值。如果对这个概念不了解，我们可以快速展示一个小示例一睹风采：

```js
let arr = [1, 2, 3]
let a = arr[0]
let b = arr[1]
let c = arr[2]
```

想从数组中找出有意义的项要单独赋值给变量，在 ES6 中就可以这样写了：

```js
let [a, b, c] = [1, 2, 3]
```

TIP

解构赋值重点是在赋值，赋值的元素是要拷贝出来赋值给变量，赋值的元素本身是不会被改变的。

是不是非常的简洁，在解构赋值里用的最多的就是 Object 和 Array ，我们可以分别来看下两者的解构赋值是如何操作的

## 数组解构赋值

上述的小示例已经在描述数组的解构赋值了，可是那只是开始。

### **赋值元素可以是任意可遍历的对象**

赋值的元素不仅是数组，它可以是任意可遍历的对象

```js
let [a, b, c] = "abc" // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3])
```

### 对象的属性赋值

被赋值的变量还可以是对象的属性，不局限于单纯的变量。

```js
let user = {}
[user.firstName, user.secondName] = 'Kobe Bryant'.split(' ')

console.log(user.firstName, user.secondName) // Kobe Bryant
```

### 循环体

解构赋值在循环体中的应用，可以配合 entries 使用。

```js
let user = {
  name: 'John',
  age: 30
}

// loop over keys-and-values
for (let [key, value] of Object.entries(user)) {
  console.log(`${key}:${value}`) // name:John, then age:30
}
```

当然，对于 map 对象依然适用：

```js
let user = new Map()
user.set('name', 'John')
user.set('age', '30')

for (let [key, value] of user.entries()) {
  console.log(`${key}:${value}`) // name:John, then age:30
}
```

### 可以跳过赋值元素

如果想忽略数组的某个元素对变量进行赋值，可以使用逗号来处理。

```js
// second element is not needed
let [name, , title] = ['John', 'Jim', 'Sun', 'Moon']

console.log( title ) // Sun
```

### rest(剩余) 参数

```js
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"]

console.log(name1) // Julius
console.log(name2) // Caesar

// Note that type of `rest` is Array.
console.log(rest[0]) // Consul
console.log(rest[1]) // of the Roman Republic
console.log(rest.length) // 2
```

> 注意
>
> 我们可以使用 rest 来接受赋值数组的剩余元素，不过要确保这个 rest 参数是放在被赋值变量的最后一个位置上。

### 默认值

如果数组的内容少于变量的个数，并不会报错，没有分配到内容的变量会是 undefined。

```js
let [firstName, surname] = []

console.log(firstName) // undefined
console.log(surname) // undefined
```

当然你也可以给变量赋予默认值，防止 undefined 的情况出现：

```js
// default values
let [name = "Guest", surname = "Anonymous"] = ["Julius"]

console.log(name)    // Julius (from array)
console.log(surname) // Anonymous (default used)
```

## 对象解构赋值

### **基本用法**

解构赋值除了可以应用在 Array，也可以应用在 Object。基本的语法如下：

> let {var1, var2} = {var1:…, var2…}

大致的意思是我们有一个 Object 想把里面的属性分别拿出来而无需通过调用属性的方式赋值给指定的变量。具体的做法是在赋值的左侧声明一个和 Object 结构等同的模板，然后把关心属性的 value 指定为新的变量即可。

```js
let options = {
  title: "Menu",
  width: 100,
  height: 200
}

let {title, width, height} = options

console.log(title)  // Menu
console.log(width)  // 100
console.log(height) // 200
```

> TIP
>
> 在这个结构赋值的过程中，左侧的“模板”结构要与右侧的 Object 一致，但是属性的顺序无需一致。

上述的赋值左侧是采用了对象简写的方式，类似于：

```js
let {title: title, width: width, height: height} = options
```

如果不想这么写或者想使用其他的变量名，可以自定义的，如下：

```js
let {width: w, height: h, title} = options
```

### 默认值

当然，这个赋值的过程中也是可以指定默认值的，这样做：

```js
let options = {
  title: "Menu"
}

let {width = 100, height = 200, title} = options

console.log(title)  // Menu
console.log(width)  // 100
console.log(height) // 200
```

### rest 运算符

如果我们想象操作数组一样，只关心指定的属性，其他可以暂存到一个变量下，这就要用到 rest 运算符了

```js
let options = {
  title: "Menu",
  height: 200,
  width: 100
}

let {title, ...rest} = options

// now title="Menu", rest={height: 200, width: 100}
console.log(rest.height)  // 200
console.log(rest.width)   // 100
```

### 嵌套对象

如果一个 Array 或者 Object 比较复杂，它嵌套了 Array 或者 Object，那只要被赋值的结构和右侧赋值的元素一致就好了。

```js
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true    // something extra that we will not destruct
}

// destructuring assignment on multiple lines for clarity
let {
  size: { // put size here
    width,
    height
  },
  items: [item1, item2], // assign items here
  title = 'Menu' // not present in the object (default value is used)
} = options

console.log(title)  // Menu
console.log(width)  // 100
console.log(height) // 200
console.log(item1)  // Cake
console.log(item2)  // Donut
```

这个原理其实很简单，如果不理解可以看下图：

![image-20230514182550901](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic@master/javaImg/image-20230514182550901.png)

## 字符串解构赋值

可以当做是数组的解构:

```js
let str = 'imooc'

let [a, b, c, d, e] = str

console.log(a, b, c, d, e)
```

**思考思考**

1. 有时候我们写一个函数需要传入很多参数，而且很多参数是可选的，是否可以利用解构赋值来简化操作呢？
2. 如何在业务开发中对接口数据进行解构赋值呢？

# Array

## ==ES5中的遍历方式==

### for循环

```js
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i])
}
```

### forEach()

```js
arr.forEach(function(elem, index, array) {
    if (arr[i] == 2) {
        continue
    }
    console.log(elem, index)
})
```

> **不支持 break、continue 等**

### copyWithin()

在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组

**语法：**`arr.copyWithin(target, start = 0, end = this.length)`

| 参数   | 含义                                                         | 必选 |
| ------ | ------------------------------------------------------------ | ---- |
| target | 从该位置开始替换数据。如果为负值，表示倒数                   | Y    |
| start  | 从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算 | N    |
| end    | 到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算 | N    |

```js
let arr = [1, 2, 3, 4, 5]
console.log(arr.copyWithin(1, 3))
// [1, 4, 5, 4, 5]
```

### for in的问题

for...in 确实可以遍历数组，而且还支持 continue、break等功能，但是如果 array 有自定义属性，你发现也会被遍历出来(显然不合理)。这是因为 for...in 是为遍历对象创造的（{a:1, b:2}），不是为数组设计的

> 注意
>
> for...in不太适合遍历数组，`for  in 遍历数组时，遍历出来的item是索引值，并且是字符串类型`。
> for...in代码块中不能有 return，不然会抛出异常。

## ES6中for of

 for...of 遍历的是一切可遍历的元素（数组、对象、集合）等

在 `ES6 中`允许开发者`自定义遍历`，换句话说`任何数据结构`都可以`自定义一个遍历`，`这个遍历是不能被 for、for...in 理解和实现的`

```js
for (let item of arr) {
    console.log(item)
}

for (let item of arr.values()) {
    console.log(item)
}

for (let item of arr.keys()) {
    console.log(item)
}

for (let [index, item] of arr.entries()) {
    console.log(index, item)
}
```

> TIP
>
> for...of是支持 break、continue、return的，所以在功能上非常贴近原生的 for。

## 其他遍历方式

### Array.from()

在 JavaScript 的世界里`有些对象被理解为数组，然而缺不能使用数组的原生 API`，比`如函数中的 arguments、DOM中的 NodeList等`。当然，还有一些可遍历的对象，看上去都像数组却不能直接使用数组的 API，因为`它们是伪数组（Array-Like）`。`要想`对这些对象`使用数组的 API` ,`就要把它们转化为数组`

#### ES6之前的转换方法:

基本原理是使用 call 将数组的 api 应用在新的对象上，换句话说是利用改变函数的上下文来间接使用数组的 api

```js
let args = [].slice.call(arguments);
let imgs = [].slice.call(document.querySelectorAll('img'));
```

#### ES6之后的转换方法: 使用`Array.from`

```js
let args = Array.from(arguments);
let imgs = Array.from(document.querySelectorAll('img'));
```

> TIP
>
> 伪数组具备两个特征，1. 按索引方式储存数据 2. 具有length属性；如：
>
> ```js
> let arrLike = {
>     0: 'a',
>     1: 'b',
>     2: 'c',
>     length: 3
> }
> ```

#### Array.from的其他用法

语法：`Array.from(arrayLike[, mapFn[, thisArg]])`

| 参数      | 含义                                                 | 是否必选 |
| --------- | ---------------------------------------------------- | -------- |
| arrayLike | 想要转换成数组的伪数组对象或可迭代对象               | Y        |
| mapFn     | 如果指定了该参数，新数组中的每个元素会执行该回调函数 | N        |
| thisArg   | 可选参数，执行回调函数 mapFn 时 this 对象            | N        |

Array.from 还具备 map 的功能

想初始化一个长度为 5 的数组，每个数组元素默认为 1

```js
Array.from({
    length: 5
}, function() {
    return 1
})
```

### Array.of()

Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型

#### Array.of和Array构造函数的区别

Array.of() 和 Array 构造函数之间的区别在于处理整数参数：

- Array.of(7) 创建一个具有单个元素 7 的数组，

- 而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有`7个空位(empty)的数组`，`而不是由7个undefined组成的数组`）

  ```js
  Array.of(7); // [7]
  Array.of(1, 2, 3); // [1, 2, 3]
  
  Array(7); // [ , , , , , , ]
  Array(1, 2, 3); // [1, 2, 3]
  ```

**语法：**`Array.of(element0[, element1[, ...[, elementN]]])`

| 参数     | 含义                                     | 是否必选 |
| -------- | ---------------------------------------- | -------- |
| elementN | 任意个参数，将按顺序成为返回数组中的元素 | Y        |

### Array.prototype.fill()

fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引

```js
let array = [1, 2, 3, 4]
array.fill(0, 1, 2)
// [1,0,3,4]
```

这个操作是将 array 数组的第二个元素（索引为1）到第三个元素（索引为2）内的数填充为 0，不包括第三个元素，所以结果是 [1, 0, 3, 4]

这个操作是将 array 数组的第二个元素（索引为1）到第三个元素（索引为2）内的数填充为 0，不包括第三个元素，所以结果是 [1, 0, 3, 4]

> 与其他数组Api不同：fille的第一个参数是需要填充的内容，第二、三个参数，才是起始和终止索引

#### 使用fill声明长度为5的数组并填充1

```js
Array(5).fill(1)
// [1,1,1,1,1]
```

> fill 不具备遍历的功能，它是通过指定要操作的索引范围来进行，通过这道题目可以看出不指定索引会对所有元素进行操作

| 参数  | 含义                           | 必选 |
| ----- | ------------------------------ | ---- |
| value | 用来填充数组元素的值           | Y    |
| start | 起始索引，默认值为0            | N    |
| end   | 终止索引，默认值为 this.length | N    |

# Function

## 默认参数

### 直接赋值

```js
function foo(x, y = 'world') {
    console.log(x, y)
}
foo('hello', 0)
```

> TIP
>
> 函数参数是`从左到右解析`，如果没有默认值会被解析成 undefined

### 逻辑运算后赋值

在ES6中我们`不仅可以给参数默认赋值具体的数值`，同时参数赋值`支持参数的逻辑运算进行赋值`

```js
function f(x, y = 7, z = x + y) {
    return z * 0.5
}

console.log(f(1, 7)) // 4
```

### 判断参数个数

在函数体内，有时候需要判断函数有几个参数，一共有2个办法。在`ES5 中可以在函数体内使用 arguments 来判断`

```js
function foo(a, b = 1, c) {
    console.log(arguments.length)
}
foo('a', 'b') //2
```

然而在 `ES6 中不能再使用 arguments 来判断了`，但可以`借助 Function.length` 来判断

> 注意：
>
> Function.length 是统计第一个默认参数前面的变量数

```js
function foo(a = 2, b = 1, c) {
    console.log(foo.length)
}
foo('a', 'b') // 0
```

## Rest参数

在写函数的时候，部分情况我们不是很确定参数有多少个，比如求和运算

```js
function sum(...nums) {
    let num = 0
    nums.forEach(function(item) {
        num += item * 1
    })
    return num
}

console.log(sum(1, 2, 3)) // 6
console.log(sum(1, 2, 3, 4)) // 10
```

当然，Rest Parameter 也可以和其他参数一起来用，比如：

```js
function sum(base, ...nums) {
    let num = base
    nums.forEach(function(item) {
        num += item * 1
    })
    return num
}

console.log(sum(30, 1, 2, 3)) // 36
console.log(sum(30, 1, 2, 3, 4)) // 40
```

> 注意
>
> arguments 不是数组，所以不能直接使用数组的原生 API 如 forEach，而 Rest Parameter 是数组，可以直接使用数组的原生 API。

## 扩展运算符

`Rest Parameter 是把不定的参数“收敛”到数组`，而` Spread Operator 是把固定的数组内容“打散”到对应的参数`

```js
function sum(x = 1, y = 2, z = 3) {
    return x + y + z
}

console.log(sum(...[4])) // 9
console.log(sum(...[4, 5])) // 12
console.log(sum(...[4, 5, 6])) // 15
```

## length属性

函数指定了默认值以后，函数的length属性，将返回`第一个有指定默认值前的，没有默认值参数的个数`

```js
function foo(x, y=2, z) {
    console.log(x, y);
}
console.log(foo.length); // 1
```

## name属性

函数的name属性，返回该函数的函数名

```js
function foo() {}

foo.name // "foo"
```

## 箭头函数

```js
let hello = (name) => {
    console.log('say hello', name)
}
// 或者

let hello = name => {
    console.log('say hello', name)
}
```

> TIP
>
> 如果只有一个参数，可以省略括号，如果大于一个参数一定要记得带括号

### 返回值

#### 表达式类型

如果返回值是表达式可以省略 return 和 {}

```js
let pow = x => x * x
```

#### 字面量类型

如果返回值是字面量对象，一定要用小括号包起来

```js
let person = (name) => ({
      age: 20,
      addr: 'Beijing City'
  })
```

#### 扩展

> 1、箭头函数中this指向定义时所在的对象，而不是调用时所在的对象
>
> 2、箭头函数不可以当作构造函数
>
> 3、箭头函数不可以使用arguments对象

```js
let foo = {
    name: 'es',
    say: () => {
        console.log(this.name, this)
    }
}
console.log(foo.say()) // undefined
```

**因为箭头函数中对 this 的处理是定义时，this 的指向也就是 foo 外层的所指向的 window，而 window 没有 name 属性，所以结果是 undefined**

# ==This详解==

# Object

## 属性简洁表示法

在 `ES6 之前` Object 的属性必须是` key-value 形式`，ES6之后，如果key和value所对应的变量名一致，可以省略:及以后的代码，如：

```js
let name = 'xiecheng'
  let age = 34
  let obj = {
      name, // 省略写法
      age, // 省略写法
      study() {
          console.log(this.name + '正在学习')
      }
  }
```

## 属性名表达式

在 ES6 可以直接用变量或者表达式来定义Object的 key

```js
let s = 'school'
let obj = {
    foo: 'bar',
    [s]: 'imooc'
}
```

## Object的Api

### Object.is()

判断两个对象是否相等， 判断的是`两个对象的内存地址是否一致`

```js
let obj1 = { // new Object()
    name: 'xiecheng',
    age: 34
}

let obj2 = { // new Object()
    name: 'xiecheng',
    age: 34
}
console.log(obj1 == obj2) // false

console.log(Object.is(obj1, obj2)) // false

let obj2 = obj1

console.log(Object.is(obj1, obj2)) // true
```

### Object.assign()

Object.assign() 方法用于`将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象`

`该Api修改第一个参数里的对象`

```js
const target = {
    a: 1,
    b: 2
}
const source = {
    b: 4,
    c: 5
}

const returnedTarget = Object.assign(target, source)

console.log(target)
// expected output: Object { a: 1, b: 4, c: 5 }

console.log(returnedTarget)
// expected output: Object { a: 1, b: 4, c: 5 }
```

> TIP
>
> 从语法上可以看出源对象的个数是不限制的（零个或多个），如果是零个直接返回目的对象，如果是多个相同属性的会被后边的源对象的属相覆盖。

> 注意
>
> 如果目的对象不是对象，则会自动转换为对象

```js
let t = Object.assign(2)
// Number {2}
let s = Object.assign(2, {
    a: 2
})
```

注意

Object.assign()对于引用数据类型属于浅拷贝，如果对象属性具有多层嵌套，需要注意

```js
let target = {
    a: {
        b: {
            c: 1
        },
        e: 4,
        f: 5,
        g: 6
    }
}
let source = {
    a: {
        b: {
            c: 1
        },
        e: 2,
        f: 3
    }
}
Object.assign(target, source)
console.log(target) //
```

![image-20230515165525750](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic@master/javaImg/image-20230515165525750.png)

### ==Object.keys==

### ==Object.values==

### ==Object.entries==

## 对象的遍历方式

定义一个对象

```js
let obj = {
    name: 'xiecheng',
    age: 34,
    school: 'imooc'
}
```

### for......in

```js
for (let key in obj) {
    console.log(key, obj[key])
}
```

### Object.keys搭配forEach

```js
Object.keys(obj).forEach(key => {
    console.log(key, obj[key])
})
```

### Object.getOwnPropertyNames()

```js
Object.getOwnPropertyNames(obj).forEach(key => {
    console.log(key, obj[key])
})
```

### Reflect.ownKeys()

```js
Reflect.ownKeys(obj).forEach(key => {
    console.log(key, obj[key])
})
```

## Object属性相关Api

### defineProperty(obj, prop, descriptor)

```js
let obj = {
    name:"诸葛钢铁",
    age:"18"
}
Object.defineProperty(obj,"idno",{
    value:"15089",//简单点就是 设置属性的值
    writable:false,//是否可操作属性值,默认值false
    configurable:false,//是否可修改配置configurable如果值为false descriptor内的属性都不可操作），默认值false
    enumerable:false//是否可枚举，默认值false。Object.keys()获取的是可枚举的，Objec.getOwnPropertyNames()获取的是所有的值。
})
```

| 属性名       | 作用                                                         | 值                      |
| ------------ | ------------------------------------------------------------ | ----------------------- |
| value        | 设置属性的值                                                 | 可以是任意类型的值      |
| writable     | 是否可操作属性值,默认值false                                 | true/false              |
| configurable | 配置configurable是否可修改<br />如果值为false descriptor内的属性都不可操作 | true/false, 默认false   |
| enumerable   | 是否可枚举，默认值false<br />Object.keys()获取的是可枚举的   | true/false，默认是false |

### hasOwnProperty

Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。

```js
var obj = {
    aa:"111"
}
console.log(obj.hasOwnProperty("aa"))//true
console.log(obj.hasOwnProperty("toString"))//false
```

### defineProperties

同defineProperty

```js
var obj = {};
Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
  'property2': {
    value: 'Hello',
    writable: false
  }
});
```

### getPrototypeOf和isPrototypeOf

getPrototypeOf此方法可以获取指定对象的原型对象
isPrototypeOf方法用于测试一个对象是否存在于另一个对象的原型链上

```js
function Person(){
  this.name="123";
  this.nofg="11";
}
Person.prototype={
  age:3,
  address:"sdag"
}
let person=new Person();
console.log(Object.getPrototypeOf(person).age);//3
console.log(Person.prototype.isPrototypeOf(person));//true
```

### getOwnPropertyNames

列出一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。
区别于Object.keys()。

```js
var aa = {
    name:"123",
    age:17
}
Object.defineProperty(aa,"idno",{
    value:"1234"//不可枚举的
})
console.log(Object.getOwnPropertyNames(aa))//["name", "age", "idno"]
```

### getOwnPropertyDescriptor和getOwnPropertyDescriptors

```js
var aa = {
    name:"123",
    nofg:11
}
console.log(Object.getOwnPropertyDescriptor(aa,"name"));
console.log(Object.getOwnPropertyDescriptors(aa));
```

![img](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic@master/javaImg/8696815-aad7036e7292eb49.png)

# Class

class 的方式是 function 方式的语法糖

## 声明类

```js
class Animal {
    constructor(type) {
        this.type = type
    }
    walk() {
        console.log( `I am walking` )
    }
}
let dog = new Animal('dog')
let monkey = new Animal('monkey')
```

## Setters & Getters

对于类中的属性，可以直接在 constructor 中通过 this 直接定义，还可以直接在类的顶层来定义

```js
class Animal {
    constructor(type, age) {
        this.type = type
        this._age = age
    }
    get age() {
        return this._age
    }
    set age(val) {
        if (val > 0 && val < 10) {
            this._age = val
        }
    }
}
```

## 静态方法

使用static修饰静态方法

```js
class Animal {
    constructor(type) {
        this.type = type
    }
    walk() {
        console.log( `I am walking` )
    }
    static eat() {
        console.log( `I am eating` )
    }
}
```

## 继承

使用extends关键字实现继承

```js
class Animal {
    constructor(type) {
        this.type = type
    }
    walk() {
        console.log( `I am walking` )
    }
    static eat() {
        console.log( `I am eating` )
    }
}

class Dog extends Animal {
  constructor () {
    super('dog')
  }
  run () {
    console.log('I can run')
  }
}
```

# Symbol

ES6 引入了一种新的原始数据类型 `Symbol` ，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）

Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突

## 声明方式

```js
let s = Symbol()

typeof s
// "symbol"
```

变量s就是一个独一无二的值。typeof的结果说明s是 Symbol 数据类型。

既然是独一无二的，那么两个Symbol()就一定是不相等的：

```js
let s1 = Symbol()
let s2 = Symbol()
console.log(s1)
console.log(s2)
console.log(s1 === s2) // false
```

> 注意
>
> Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。

Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

```js
let s1 = Symbol('foo')
let s2 = Symbol('foo')
console.log(s1)
console.log(s2)
console.log(s1 === s2) // false
```

## Symbol.for()

`Symbol.for()` 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。

```js
let s1 = Symbol.for('foo')
let s2 = Symbol.for('foo')
console.log(s1 === s2) // true
```

> 注意
>
> Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。

## Symbol.keyFor()

Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。

```js
const s1 = Symbol('foo')
console.log(Symbol.keyFor(s1)) // undefined

const s2 = Symbol.for('foo')
console.log(Symbol.keyFor(s2)) // foo
```

## 作为属性名

由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

比如在一个班级中，可能会有同学名字相同的情况，这时候使用对象来描述学生信息的时候，如果直接使用学生姓名作为key会有有问题。

```js
const grade = {
    张三: {
        address: 'xxx',
        tel: '111'
    },
    李四: {
        address: 'yyy',
        tel: '222'
    },
    李四: {
        address: 'zzz',
        tel: '333'
    },
}
console.log(grade)
// 只会保留最后一个李四
```

如果使用Symbol，同名的学生信息就不会被覆盖：

```js
const stu1 = Symbol('李四')
const stu2 = Symbol('李四')
const grade = {
    [stu1]: {
        address: 'yyy',
        tel: '222'
    },
    [stu2]: {
        address: 'zzz',
        tel: '333'
    },
}
console.log(grade)
console.log(grade[stu1])
console.log(grade[stu2])
```

## 属性变量

```js
const sym = Symbol('imooc')
class User {
    constructor(name) {
        this.name = name
        this[sym] = 'imooc.com'
    }
    getName() {
        return this.name + this[sym]
    }
}
const user = new User('xiecheng')
console.log(user.getName())

for (let key in user) {
    console.log(key)
}

for (let key of Object.keys(user)) {
    console.log(key)
}

for (let key of Object.getOwnPropertySymbols(user)) {
    console.log(key)
}

for (let key of Reflect.ownKeys(user)) {
    console.log(key)
}
```

## 消除魔术字符串

魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替

```js
function getArea(shape) {
    let area = 0
    switch (shape) {
        case 'Triangle':
            area = 1
            break
        case 'Circle':
            area = 2
            break
    }
    return area
}
console.log(getArea('Triangle'))
```

上面代码中，字符串Triangle和Circle就是魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。

使用Symbol就可以很好的解决这个问题：

```js
const shapeType = {
    triangle: Symbol(),
    circle: Symbol()
}

function getArea(shape) {
    let area = 0
    switch (shape) {
        case shapeType.triangle:
            area = 1
            break
        case shapeType.circle:
            area = 2
            break
    }
    return area
}
console.log(getArea(shapeType.triangle))
```



# ==BigInt==

至此，js的全部数据类型已经完毕。

js的基本数据类型有：

1. undefined
2. null
3. 布尔值（Boolean）
4. 字符串（String）
5. 数值（Number）
6. 对象（Object）
7. Symbol
8. BigInt

# Set

ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值

## 基本语法

### 声明Set变量

```js
let s = new Set() 
let s = new Set([1, 2, 3, 4])
```

> 注意
>
> 初始化的参数必须是可遍历的，可以是数组或者自定义遍历的数据结构。

### 添加数据

```js
s.add('hello')
s.add('goodbye')
```

或者使用链式调用

```js
s.add('hello').add('goodbye')
```

> 注意
>
> Set 数据结构不允许数据重复，所以添加重复的数据是无效的

### 删除数据

#### 删除指定数据

使用delete，返回是否删除成功(true/false)：如果删除成功，返回true，如果删除未成功，返回false

```js
// 删除指定数据
s.delete('hello') // true
```

#### 清空数据

```js
// 删除全部数据
s.clear()
```

### 统计数据

Set 可以快速进行统计数据，如数据是否存在、数据的总数。

#### has关键字

has用来判断set中存不存在该元素

```js
 // 判断是否包含数据项，返回 true 或 false
  s.has('hello') // true
```

#### size关键字

size关键字用来统计set的长度

```js
// 计算数据项总数
s.size // 2
```

### 数组去重

```js
let arr = [1, 2, 3, 4, 2, 3]
let s = new Set(arr)
console.log(s)
```

### 合并去重

```js
let arr1 = [1, 2, 3, 4]
let arr2 = [2, 3, 4, 5, 6]
let s = new Set([...arr1, ...arr2])
console.log(s)
console.log([...s])
console.log(Array.from(s))
```

### 交集

```js
let s1 = new Set(arr1)
let s2 = new Set(arr2)
let result = new Set(arr1.filter(item => s2.has(item)))
console.log(Array.from(result))
```

### 差集

```js
let arr3 = new Set(arr1.filter(item => !s2.has(item)))
let arr4 = new Set(arr2.filter(item => !s1.has(item)))
console.log(arr3)
console.log(arr4)
console.log([...arr3, ...arr4])
```

## 遍历方式

### keys

**keys()：返回键名的遍历器**

### values

**values()：返回键值的遍历器**

### entries()

**entries()：返回键值对的遍历器**

### forEach()

**forEach()：使用回调函数遍历每个成员**

### for...of

**for...of：可以直接遍历每个成员**

```js
console.log(s.keys()) // SetIterator {"hello", "goodbye"}
  console.log(s.values()) // SetIterator {"hello", "goodbye"}
  console.log(s.entries()) // SetIterator {"hello" => "hello", "goodbye" => "goodbye"}
  s.forEach(item => {
      console.log(item) // hello // goodbye
  })

  for (let item of s) {
      console.log(item)
  }

  for (let item of s.keys()) {
      console.log(item)
  }

  for (let item of s.values()) {
      console.log(item)
  }

  for (let item of s.entries()) {
      console.log(item[0], item[1])
  }
```

## WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合。

### 与 Set 有两个区别。

1. `WeakSet 的成员只能是对象`，而`不能是其他类型的值`

   ```js
   const ws = new WeakSet()
   ws.add(1)
   // TypeError: Invalid value used in weak set
   ws.add(Symbol())
   // TypeError: invalid value used in weak set
   ```

2. WeakSet 没有size属性，没有办法遍历它的成员

   ```js
   let ws = new WeakSet()
   const obj1 = {
       name: 'imooc'
   }
   const obj2 = {
       age: 5
   }
   ws.add(obj1)
   ws.add(obj2)
   ws.delete(obj1)
   console.log(ws)
   console.log(ws.has(obj2))
   ```

WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，**如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中**

# Map

ES6 提供了 Map 数据结构。它**类似于对象，也是键值对的集合**，但是**“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键**。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适

## 基本语法

### 实例化

```js
let map = new Map([iterable])
```

Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, 'one' ], [ 2, 'two' ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。

### 添加数据

```js
let keyObj = {}
let keyFunc = function() {}
let keyString = 'a string'

// 添加键
map.set(keyString, "和键'a string'关联的值")
map.set(keyObj, '和键keyObj关联的值')
map.set(keyFunc, '和键keyFunc关联的值')
```

### 删除数据

```js
// 删除指定的数据
map.delete(keyObj)
// 删除所有数据
map.clear()
```

### 统计数据

```js
// 统计所有 key-value 的总数
console.log(map.size) //2
// 判断是否有 key-value
console.log(map.has(keyObj)) // true
```

### 查询数据

- get() 方法返回某个 Map 对象中的一个指定元素

  ```js
  console.log(map.get(keyObj)) // 和键keyObj关联的值
  ```

## 遍历方式

- keys() 返回一个新的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的 key 值

- values() 方法返回一个新的 Iterator 对象。它包含按顺序插入Map对象中每个元素的 value 值

- entries() 方法返回一个新的包含 [key, value] 对的 Iterator ? 对象，返回的迭代器的迭代顺序与 Map 对象的插入顺序相同

- forEach() 方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数

- for...of 可以直接遍历每个成员

  ```js
  map.forEach((value, key) => console.log(value, key))
  
  for (let [key, value] of map) {
      console.log(key, value)
  }
  
  for (let key of map.keys()) {
      console.log(key)
  }
  
  for (let value of map.values()) {
      console.log(value)
  }
  
  for (let [key, value] of map.entries()) {
      console.log(key, value)
  }
  ```

## Object和Map的区别

### 键的类型

一个**Object**的键**只能是字符串或者 Symbols**，但一个 **Map** 的键**可以是任意值，包括函数、对象、基本类型**。

### 键的顺序

**Map 中的键值是有序的**，**而添加到对象中的键则不是**。因此，当对它**进行遍历时，Map 对象是按插入的顺序返回键值**。

### 键值对的统计

你可以**通过 size 属性直接获取一个 Map 的键值对个数**，而 **Object** 的键值对个数**只能手动计算**

### 键值对的遍历

**Map 可直接进行迭代**，而 **Object 的迭代需要先获取它的键数组**，然后再进行迭代

### 性能

**Map 在涉及频繁增删键值对的场景下会有些性能优势**

## WeakMap

WeakMap结构与Map结构类似，也是用于生成键值对的集合

```js
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap()
const key = {
    foo: 1
}
wm1.set(key, 2)
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3]
const k2 = [4, 5, 6]
const wm2 = new WeakMap([
    [k1, 'foo'],
    [k2, 'bar']
])
wm2.get(k2) // "bar"
```

WeakMap与Map的区别有两点。

- **WeakMap只接受对象作为键名**（null除外），不接受其他类型的值作为键名。

  ```js
  const map = new WeakMap()
  map.set(1, 2)
  // TypeError: 1 is not an object!
  map.set(Symbol(), 2)
  // TypeError: Invalid value used as weak map key
  map.set(null, 2)
  // TypeError: Invalid value used as weak map key
  ```

- **WeakMap的键名所指向的对象，不计入垃圾回收机制**。

# String

## Unicode表示法

ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点

[详细内容，参照博客](http://es.xiecheng.live/es6/string.html#unicode%E8%A1%A8%E7%A4%BA%E6%B3%95)

## 遍历器接口

ES6 为字符串添加了遍历器接口，详见Iterator一节，使得字符串可以被for...of循环遍历。

```js
for (let item of 'imooc') {
    console.log(item)
}
```

## 模板字符串

### 可以书写变量

```js
const temp = `string text ${expression} string text` 
```

### 可以换行

摒弃了ES6之前，需要使用\n才能实现换行的窘境

```js
console.log(`string text line 1
string text line 2`)
```

### 表达式

```js
const a = 20;
const b = 10;
const c = "JavaScript";
const str = `My age is ${a+b} and I love ${c}`;
console.log(str);
//output “My age is 30 and I love JavaScript"
```

## 扩展方法

### fromCodePoint()

用于**从 Unicode 码点返回对应字符**，并且可以识别大于0xFFFF的字符。

```js
// ES5
console.log(String.fromCharCode(0x20BB7))

// ES6
console.log(String.fromCodePoint(0x20BB7))
```

### includes()

ES5中可以使用indexOf方法来**判断一个字符串是否包含在另一个字符串中**，indexOf返回出现的下标位置，**如果不存在则返回-1**。

```js
const str = 'imooc'

console.log(str.indexOf('mo'))
```

### startsWith()

判断参数字符串是否在原字符串的头部, 返回boolean类型的值。

```js
const str = 'imooc'

console.log(str.startsWith('im'))	
```

### endsWith()

判断参数字符串是否在原字符串的尾部, 返回boolean类型的值

```js
const str = 'imooc'

console.log(str.endsWith('mooc'))
```

### repeat()

repeat方法返回一个新字符串，表示将原字符串重复n次

```js
const str = 'imooc'

const newStr = str.repeat(10)

console.log(newStr)
```

# RegExp

## y修饰符

ES6为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。

y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，**g修饰符只要剩余位置中存在匹配就可**，而**y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义**。

```js
const s = 'aaa_aa_a'
const r1 = /a+/g
const r2 = /a+/y

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
```

上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。

如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。

```js
const s = 'aaa_aa_a'
const r = /a+_/y

r.exec(s) // ["aaa_"]
r.exec(s) // ["aa_"]
```

上面代码每次匹配，都是从剩余字符串的头部开始。

使用lastIndex属性，可以更好地说明y修饰符。

```js
const regexp = /a/g

// 指定从2号位置（y）开始匹配
regexp.lastIndex = 2

// 匹配成功
const match = regexp.exec('xaya')

// 在3号位置匹配成功
console.log(match.index) // 3

// 下一次匹配从4号位开始
console.log(regexp.lastIndex) // 4

// 4号位开始匹配失败
regexp.exec('xaxa') // null
```

上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。

y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。

```js
const regexp = /a/y

// 指定从2号位置开始匹配
regexp.lastIndex = 2

// 不是粘连，匹配失败
regexp.exec('xaya') // null

// 指定从3号位置开始匹配
regexp.lastIndex = 3

// 3号位置是粘连，匹配成功
const match = regexp.exec('xaxa')
console.log(match.index) // 3
console.log(regexp.lastIndex) // 4
```

进一步说，y修饰符号隐含了头部匹配的标志^。

```js
const reg = /b/y
reg.exec('aba')
// null
console.log(reg.lastIndex)
```

TIP

sticky 模式在正则匹配过程中只会影响两件事：

- 匹配必须从 re.lastIndex 开始（相当于正则表达中的 ^）
- 如果匹配到会修改 re.lastIndex（相当于 g 模式）

## u修饰符

ES6为正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于 `\uFFFF` 的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。

```js
/^\uD83D/u.test('\uD83D\uDC2A') // false

/^\uD83D/.test('\uD83D\uDC2A') // true
```

上面代码中， `\uD83D\uDC2A` 是一个四个字节的UTF-16编码，代表一个字符 "🐪"。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为false。

一旦加上u修饰符号，就会修改下面这些正则表达式的行为。

**(1) 点字符**

点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上u修饰符。

```js
let s = '𠮷'

/^.$/.test(s) // false

/^.$/u.test(s) // true
```

上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。

TIP

'𠮷'这个字读 jí，是'吉'字的异形体，Unicode 码点 [U+20BB7](https://www.fileformat.info/info/unicode/char/20bb7/index.htm)

**(2) Unicode字符表示法**

ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。

```js
/\u{61}/.test('a') // false

/\u{61}/u.test('a') / / true

/\u{20BB7}/u.test('𠮷') / / true
```

上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配61个连续的u。

**(3) 量词**

使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。

```js
/a{2}/.test('aa') // true

/a{2}/u.test('aa') // true

/𠮷{2}/.test('𠮷𠮷') // false

/𠮷{2}/u.test('𠮷𠮷') // true
```

另外，只有在使用u修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。

```js
/^\u{3}$/.test('uuu') // true
```

上面代码中，由于正则表达式没有u修饰符，所以大括号被解读为量词。加上u修饰符，就会被解读为Unicode表达式。

```js
/\u{20BB7}{2}/u.test('𠮷𠮷') // true
```

使用 u 修饰符之后 Unicode 表达式+量词也是可以的。

**(4) 预定义模式**

u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。

```js
/^\S$/.test('𠮷') // false

/^\S$/u.test('𠮷') // true
```

上面代码的\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。

利用这一点，可以写出一个正确返回字符串长度的函数。

```js
function codePointLength(text) {
    const result = text.match(/[\s\S]/gu)
    return result ? result.length : 0
}

const s = '𠮷𠮷'

s.length // 4
codePointLength(s) // 2
```

**(5) i修饰符**

有些Unicode字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。

```js
/[a-z]/i.test('\u212A') // false

/[a-z]/iu.test('\u212A') // true
```

上面代码中，不加u修饰符，就无法识别非规范的K字符。

# Number

## 二进制与八进制

### 十进制转化为二进制

```js
const a = 5 // 101

console.log(a.toString(2))
```

### 二进制转化为十进制

```js
const b = 101

console.log(parseInt(b, 2))
```

ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。

```js
const a = 0B0101
console.log(a)

const b = 0O777
console.log(b)
```

## 新增方法

### isFinite()

用来检查一个数值是否为有限的（finite），即不是Infinity。

```js
Number.isFinite(15) // true
Number.isFinite(0.8) // true
Number.isFinite(NaN) // false
Number.isFinite(Infinity) // false
Number.isFinite(-Infinity) // false
Number.isFinite('foo') // false
Number.isFinite('15') // false
Number.isFinite(true) // false
```

### isNaN()

用来检查一个值是否为NaN。

```js
Number.isNaN(NaN) // true
Number.isNaN(15) // false
Number.isNaN('15') // false
Number.isNaN(true) // false
Number.isNaN(9 / NaN) // true
Number.isNaN('true' / 0) // true
Number.isNaN('true' / 'true') // true
```

### parseInt()

ES6 将全局方法parseInt()移植到Number对象上面，行为完全保持不变。 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

```js
// ES5的写法
parseInt('12.34') // 12

// ES6的写法
Number.parseInt('12.34') // 12
```

### parseFloat()

ES6 将全局方法parseFloat()移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

```js
// ES5的写法
parseFloat('123.45#') // 123.45

// ES6的写法
Number.parseFloat('123.45#') // 123.45
```

### isInteger()

用来判断一个数值是否为整数。

```js
Number.isInteger(25) // true
Number.isInteger(25.1) // false

Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger('15') // false
Number.isInteger(true) // false
```

### MAX_SAFE_INTEGER

```js
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true

Number.MAX_SAFE_INTEGER === 9007199254740991 // true
```

### MIN_SAFE_INTEGER

```js
Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true

Number.MIN_SAFE_INTEGER === -9007199254740991 // true
```

### isSafeInteger()

JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。

```js
Math.pow(2, 53) // 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1 // true
```

# Proxy

## 基本语法

**语法**

```js
let p = new Proxy(target, handler)
```

| 参数   | 含义                                                         | 必填 |
| ------ | ------------------------------------------------------------ | ---- |
| target | 用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） | Y    |
| handle | 一个对象，其属性是当执行一个操作时定义代理的行为的函数       | Y    |

**第一个参数** target 就是**用来代理的“对象”，被代理之后它是不能直接被访问的**，而 handler 就是实现代理的过程

## 拦截操作场景

### 读操作场景

我们经常读取一个对象的 key-value：

```js
let o = {
    name: 'xiaoming',
    age: 20
}

console.log(o.name) // xiaoming
console.log(o.age) // 20
console.log(o.from) // undefined
```

当我们读取 from 的时候返回的是 undefined，因为 o 这个对象中没有这个 key-value。想想看我们在读取数据的时候，这个数据经常是聚合的，当大家没有按照规范来的时候或者数据缺失的情况下，经常会出现这种“乌龙”现象。

如果我们不想在调用 key 的时候返回 undefined，之前的做法是这样的：

```js
console.log(o.from || '')
```

如果我们对所有代码都是这种写法，那阅读性和观赏性就不得而知了。值得庆幸的是，ES6 的 Proxy 可以让我们轻松的解决这一问题：

```js
let o = {
    name: 'xiaoming',
    age: 20
}

let handler = {
    get(obj, key) {
        return Reflect.has(obj, key) ? obj[key] : ''
    }
}

let p = new Proxy(o, handler)

console.log(p.from)
```

这个代码是想表达如果 o 对象有这个 key-value 则直接返回，如果没有一律返回 `''` ，当然这里是自定义，大家可以根据自己的需要来写适合自己业务的规则。

刚才对数据的“读操作”进行了拦截，接下来我们描述下“写操作”进行拦截。

### 写操作场景

#### **场景 1**

从服务端获取的数据希望是只读，不允许在任何一个环节被修改。

```js
// response.data 是 JSON 格式的数据，来自服务端的响应
// 在 ES5 中只能通过遍历把所有的属性设置为只读
for (let [key] of Object.entries(response.data)) {
    Object.defineProperty(response.data, key, {
        writable: false
    })
}
```

如果我们使用 Proxy 就简单很多了：

```js
let data = new Proxy(response.data, {
    set(obj, key, value) {
        return false
    }
})
```

#### **场景 2**

对于数据交互而言，校验是不可或缺的一个环境，传统的做法是将校验写在了业务逻辑里，导致代码耦合度较高。如果大家使用 Proxy 就可以将代码设计的非常灵活。

```js
// Validator.js
export default (obj, key, value) => {
    if (Reflect.has(key) && value > 20) {
        obj[key] = value
    }
}

import Validator from './Validator'
let data = new Proxy(response.data, {
    set: Validator
})
```

#### **场景 3**

如果对读写进行监控，可以这样写：

```js
let validator = {
    set(target, key, value) {
        if (key === 'age') {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                throw new TypeError('Age must be a number')
            }
            if (value <= 0) {
                throw new TypeError('Age must be a positive number')
            }
        }
        return true
    }
}
const person = {
    age: 27
}
const proxy = new Proxy(person, validator)
proxy.age = 'foo'
// <- TypeError: Age must be a number
proxy.age = NaN
// <- TypeError: Age must be a number
proxy.age = 0
// <- TypeError: Age must be a positive number
proxy.age = 28
console.log(person.age)
// <- 28

// 添加监控
window.addEventListener(
    'error',
    e => {
        console.log(e.message) // Uncaught TypeError: Age must be a number
    },
    true
)
```

#### **场景 4**

什么实例一个对象，每个对象都有一个自己的 id 而且只读。

```js
class Component {
    constructor() {
        this.proxy = new Proxy({
            id: Math.random().toString(36).slice(-8)
        })
    }
    get id() {
        return this.proxy.id
    }
}
```

## 常用拦截操作

### get

拦截对象属性的读取，比如proxy.foo和proxy['foo']。

```js
let arr = [7, 8, 9]
arr = new Proxy(arr, {
    get(target, prop) {
        // console.log(target, prop)
        return prop in target ? target[prop] : 'error'
    }
})
console.log(arr[1])
console.log(arr[10])
let dict = {
    'hello': '你好',
    'world': '世界'
}
dict = new Proxy(dict, {
    get(target, prop) {
        return prop in target ? target[prop] : prop
    }
})
console.log(dict['world'])
console.log(dict['imooc'])
```

### set

拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。

```js
let arr = []
arr = new Proxy(arr, {
    set(target, prop, val) {
        if (typeof val === 'number') {
            target[prop] = val
            return true
        } else {
            return false
        }
    }
})
arr.push(5)
arr.push(6)
console.log(arr[0], arr[1], arr.length)
```

### has

拦截propKey in proxy的操作，返回一个布尔值。

```js
let range = {
    start: 1,
    end: 5
}

range = new Proxy(range, {
    has(target, prop) {
        return prop >= target.start && prop <= target.end
    }
})
console.log(2 in range)
console.log(9 in range)
```

### ownKeys

拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。

```js
let obj = {
    name: 'imooc',
    [Symbol('es')]: 'es6'
}
console.log(Object.getOwnPropertyNames(obj))
console.log(Object.getOwnPropertySymbols(obj))
console.log(Object.keys(obj))
for (let key in obj) {
    console.log(key)
}
let userinfo = {
    username: 'xiecheng',
    age: 34,
    _password: '***'
}
userinfo = new Proxy(userinfo, {
    ownKeys(target) {
        return Object.keys(target).filter(key => !key.startsWith('_'))
    }
})

// for (let key in userinfo) {
//     console.log(key)
// }
console.log(Object.keys(userinfo))
```

### deleteProperty

拦截delete proxy[propKey]的操作，返回一个布尔值。

```js
let user = {
    name: 'xiecheng',
    age: 34,
    _password: '***'
}
user = new Proxy(user, {
    get(target, prop) {
        if (prop.startsWith('_')) {
            throw new Error('不可访问')
        } else {
            return target[prop]
        }
    },
    set(target, prop, val) {
        if (prop.startsWith('_')) {
            throw new Error('不可访问')
        } else {
            target[prop] = val
            return true
        }
    },
    deleteProperty(target, prop) { // 拦截删除
        if (prop.startsWith('_')) {
            throw new Error('不可删除')
        } else {
            delete target[prop]
            return true
        }
    },
    ownKeys(target) {
        return Object.keys(target).filter(key => !key.startsWith('_'))
    }
})
console.log(user.age)
console.log(user._password)
user.age = 18
console.log(user.age)
try {
    user._password = 'xxx'
} catch (e) {
    console.log(e.message)
}

try {
    // delete user.age
    delete user._password
} catch (e) {
    console.log(e.message)
}
console.log(user.age)

for (let key in user) {
    console.log(key)
}
```

### apply

拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。

```js
let sum = (...args) => {
    let num = 0
    args.forEach(item => {
        num += item
    })
    return num
}

sum = new Proxy(sum, {
    apply(target, ctx, args) {
        return target(...args) * 2
    }
})
console.log(sum(1, 2))
console.log(sum.call(null, 1, 2, 3))
console.log(sum.apply(null, [1, 2, 3]))
```

### construct

拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。

```js
let User = class {
    constructor(name) {
        this.name = name
    }
}
User = new Proxy(User, {
    construct(target, args, newTarget) {
        console.log('construct')
        return new target(...args)
    }
})
console.log(new User('imooc'))
```

# Reflect

## 设计目的

- 将Object属于语言内部的方法放到Reflect上

```js
let obj = {}
let newVal = ''
Reflect.defineProperty(obj, 'name', {
    get() {
        return newVal
    },
    set(val) {
        console.log('set')
        // this.name = val
        newVal = val
    }
})
obj.name = 'es'
console.log(obj.name)
```

- 修改某些Object方法的返回结果，让其变得更合理

```js
// 老写法
try {
    Object.defineProperty(target, property, attributes)
    // success
} catch (e) {
    // failure
}

// 新写法
if (Reflect.defineProperty(target, property, attributes)) {
    // success
} else {
    // failure
}
```

- 让Object操作变成函数行为

```js
// 老写法
'assign' in Object // true

// 新写法
Reflect.has(Object, 'assign') // true
```

- Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。

```js
Proxy(target, {
    set: function(target, name, value, receiver) {
        var success = Reflect.set(target, name, value, receiver)
        if (success) {
            console.log('property ' + name + ' on ' + target + ' set to ' + value)
        }
        return success
    }
})
```

Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法，这些方法与处理器对象的方法相同。Reflect不是一个函数对象，因此它是不可构造的。

TIP

与大多数全局对象不同，Reflect没有构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像Math对象）

## 常用方法

### Reflect.apply()

**语法**

> Reflect.apply(target, thisArgument, argumentsList)

**解释**

|     参数      |                             含义                             | 必选 |
| :-----------: | :----------------------------------------------------------: | :--: |
|    target     |                           目标函数                           |  Y   |
| thisArgument  |                target函数调用时绑定的this对象                |  N   |
| argumentsList | target函数调用时传入的实参列表，该参数应该是一个类数组的对象 |  N   |

**示例**

```js
Reflect.apply(Math.floor, undefined, [1.75])
// 1

Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111])
// "hello"

Reflect.apply(RegExp.prototype.exec, /ab/, ['confabulation']).index
// 4

Reflect.apply(''.charAt, 'ponies', [3])
// "i"
```

**ES5 对比**

该方法与ES5中Function.prototype.apply()方法类似：调用一个方法并且显式地指定this变量和参数列表(arguments) ，参数列表可以是数组，或类似数组的对象。

```js
Function.prototype.apply.call(Math.floor, undefined, [1.75])
```

### Reflect.construct()

Reflect.construct() 方法的行为有点像 new 操作符 构造函数 ， 相当于运行 new target(...args).

**语法**

> Reflect.construct(target, argumentsList[, newTarget])

**解释**

|     参数      |                             含义                             | 必选 |
| :-----------: | :----------------------------------------------------------: | :--: |
|    target     |                       被运行的目标函数                       |  Y   |
| argumentsList |                 调用构造函数的数组或者伪数组                 |  Y   |
|   newTarget   | 该参数为构造函数， 参考 new.target 操作符，如果没有newTarget参数， 默认和target一样 |  N   |

> [! WARNING] 如果target或者newTarget不是构造函数，抛出TypeError

Reflect.construct允许你使用可变的参数来调用构造函数

```js
var obj = new Foo(...args)
var obj = Reflect.construct(Foo, args)
```

**示例**

```js
var d = Reflect.construct(Date, [1776, 6, 4])
d instanceof Date // true
d.getFullYear() // 1776
```

如果使用 newTarget 参数，则表示继承了 newTarget 这个超类：

```js
function someConstructor() {}
var result = Reflect.construct(Array, [], someConstructor)

Reflect.getPrototypeOf(result) // 输出：someConstructor.prototype
Array.isArray(result) // true
```

### Reflect.defineProperty()

静态方法 Reflect.defineProperty() 基本等同于 Object.defineProperty() 方法，唯一不同是返回 Boolean 值。

**语法**

> Reflect.defineProperty(target, propertyKey, attributes)

**解释**

|    参数     |           含义           | 必选 |
| :---------: | :----------------------: | :--: |
|   target    |         目标对象         |  Y   |
| propertyKey | 要定义或修改的属性的名称 |  Y   |
| attributes  | 要定义或修改的属性的描述 |  Y   |

**示例**

```js
const student = {}
Reflect.defineProperty(student, 'name', {
    value: 'Mike'
}) // true
student.name // "Mike"
```

### Reflect.deleteProperty()

Reflect.deleteProperty 允许你删除一个对象上的属性。返回一个 Boolean 值表示该属性是否被成功删除。它几乎与非严格的 delete operator 相同。

**语法**

> Reflect.deleteProperty(target, propertyKey)

**解释**

|    参数     |         含义         | 必选 |
| :---------: | :------------------: | :--: |
|   target    |  删除属性的目标对象  |  Y   |
| propertyKey | 将被删除的属性的名称 |  Y   |

**示例**

```js
var obj = {
    x: 1,
    y: 2
}
Reflect.deleteProperty(obj, "x") // true
obj // { y: 2 }

var arr = [1, 2, 3, 4, 5]
Reflect.deleteProperty(arr, "3") // true
arr // [1, 2, 3, , 5]

// 如果属性不存在，返回 true
Reflect.deleteProperty({}, "foo") // true

// 如果属性不可配置，返回 false
Reflect.deleteProperty(Object.freeze({
    foo: 1
}), "foo") // false
```

### Reflect.get()

Reflect.get() 方法的工作方式，就像从 object (target[propertyKey]) 中获取属性，但它是作为一个函数执行的。

**语法**

> Reflect.get(target, propertyKey[, receiver])

**解释**

|    参数     |                 含义                  | 必选 |
| :---------: | :-----------------------------------: | :--: |
|   target    |          需要取值的目标对象           |  Y   |
| propertyKey |          需要获取的值的键值           |  Y   |
|  receiver   | 如果遇到 getter，此值将提供给目标调用 |  N   |

**示例**

```js
// Object
var obj = {
    x: 1,
    y: 2
}
Reflect.get(obj, 'x') // 1

// Array
Reflect.get(['zero', 'one'], 1) // "one"

// Proxy with a get handler
var x = {
    p: 1
}
var obj = new Proxy(x, {
    get(t, k, r) {
        return k + 'bar'
    }
})
Reflect.get(obj, 'foo') // "foobar"
```

### Reflect.getOwnPropertyDescriptor()

静态方法 Reflect.getOwnPropertyDescriptor() 与 Object.getOwnPropertyDescriptor() 方法相似。如果在对象中存在，则返回给定的属性的属性描述符，否则返回 undefined。

**语法**

> Reflect.getOwnPropertyDescriptor(target, propertyKey)

**解释**

|    参数     |               含义               | 必选 |
| :---------: | :------------------------------: | :--: |
|   target    |      需要寻找属性的目标对象      |  Y   |
| propertyKey | 获取自己的属性描述符的属性的名称 |  N   |

**示例**

```js
Reflect.getOwnPropertyDescriptor({
    x: 'hello'
}, 'x')
// {value: "hello", writable: true, enumerable: true, configurable: true}

Reflect.getOwnPropertyDescriptor({
    x: 'hello'
}, 'y')
// undefined

Reflect.getOwnPropertyDescriptor([], 'length')
// {value: 0, writable: true, enumerable: false, configurable: false}
```

**对比**

如果该方法的第一个参数不是一个对象（一个原始值），那么将造成 TypeError 错误。而对于 Object.getOwnPropertyDescriptor，非对象的第一个参数将被强制转换为一个对象处理。

```js
Reflect.getOwnPropertyDescriptor("foo", 0)
// TypeError: "foo" is not non-null object

Object.getOwnPropertyDescriptor("foo", 0)
// { value: "f", writable: false, enumerable: true, configurable: false }
```

### Reflect.getPrototypeOf()

静态方法 Reflect.getPrototypeOf() 与 Object.getPrototypeOf() 方法是一样的。都是返回指定对象的原型（即，内部的 [[Prototype]] 属性的值）。

**语法**

> Reflect.getPrototypeOf(target)

**解释**

|  参数  |        含义        | 必选 |
| :----: | :----------------: | :--: |
| target | 获取原型的目标对象 |  Y   |

### Reflect.has()

Reflect.has 用于检查一个对象是否拥有某个属性， 相当于in 操作符

**语法**

> Reflect.has(target, propertyKey)

**解释**

|    参数     |                  含义                  | 必选 |
| :---------: | :------------------------------------: | :--: |
|   target    |           获取原型的目标对象           |  Y   |
| propertyKey | 属性名，需要检查目标对象是否存在此属性 |  Y   |

### Reflect.isExtensible()

Reflect.isExtensible 判断一个对象是否可扩展 （即是否能够添加新的属性），它与 Object.isExtensible() 方法一样。

**语法**

> Reflect.isExtensible(target)

*解释**

|  参数  |        含义        | 必选 |
| :----: | :----------------: | :--: |
| target | 获取原型的目标对象 |  Y   |

### Reflect.ownKeys()

Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))

**语法**

> Reflect.ownKeys(target)

*解释**

|  参数  |        含义        | 必选 |
| :----: | :----------------: | :--: |
| target | 获取原型的目标对象 |  Y   |

**示例**

```js
Reflect.ownKeys({
    z: 3,
    y: 2,
    x: 1
}) // [ "z", "y", "x" ]
Reflect.ownKeys([]) // ["length"]

var sym = Symbol.for("comet")
var sym2 = Symbol.for("meteor")
var obj = {
    [sym]: 0,
    "str": 0,
    "773": 0,
    "0": 0,
    [sym2]: 0,
    "-1": 0,
    "8": 0,
    "second str": 0
}
Reflect.ownKeys(obj)
// [ "0", "8", "773", "str", "-1", "second str", Symbol(comet), Symbol(meteor) ]
// Indexes in numeric order,
// strings in insertion order,
// symbols in insertion order
```

### Reflect.preventExtensions()

Reflect.preventExtensions 方法阻止新属性添加到对象 例如：防止将来对对象的扩展被添加到对象中)。该方法与 Object.preventExtensions() 方法一致

**语法**

> Reflect.preventExtensions(target)

*解释**

|  参数  |        含义        | 必选 |
| :----: | :----------------: | :--: |
| target | 获取原型的目标对象 |  Y   |

**示例**

```js
// Objects are extensible by default.
var empty = {}
Reflect.isExtensible(empty) // === true

// ...but that can be changed.
Reflect.preventExtensions(empty)
Reflect.isExtensible(empty) // === false
Reflect.preventExtensions(1)
// TypeError: 1 is not an object

Object.preventExtensions(1)
// 1
```

### Reflect.set()

Reflect.set 方法允许你在对象上设置属性。它的作用是给属性赋值并且就像 property accessor 语法一样，但是它是以函数的方式。

**语法**

> Reflect.set(target, propertyKey, value[, receiver])

*解释**

|    参数     |                  含义                  | 必选 |
| :---------: | :------------------------------------: | :--: |
|   target    |           获取原型的目标对象           |  Y   |
| propertyKey |            设置的属性的名称            |  Y   |
|    value    |                设置的值                |  Y   |
|  receiver   | 如果遇到 setter，this 将提供给目标调用 |  N   |

**示例**

```js
// Object
var obj = {}
Reflect.set(obj, "prop", "value") // true
obj.prop // "value"

// Array
var arr = ["duck", "duck", "duck"]
Reflect.set(arr, 2, "goose") // true
arr[2] // "goose"

// It can truncate an array.
Reflect.set(arr, "length", 1) // true
arr // ["duck"]

// With just one argument, propertyKey and value are "undefined".
var obj = {}
Reflect.set(obj) // true
Reflect.getOwnPropertyDescriptor(obj, "undefined")
// { value: undefined, writable: true, enumerable: true, configurable: true }
```

### Reflect.setPrototypeOf()

Reflect.setPrototypeOf 方法改变指定对象的原型 （即，内部的 [[Prototype]] 属性值）

**语法**

> Reflect.setPrototypeOf(target, prototype)

**解释**

|   参数    |               含义               | 必选 |
| :-------: | :------------------------------: | :--: |
|  target   |        获取原型的目标对象        |  Y   |
| prototype | 对象的新原型 （一个对象或 null） |  Y   |

**示例**

```js
Reflect.setPrototypeOf({}, Object.prototype) // true

// It can change an object's [[Prototype]] to null.
Reflect.setPrototypeOf({}, null) // true

// Returns false if target is not extensible.
Reflect.setPrototypeOf(Object.freeze({}), null) // false

// Returns false if it cause a prototype chain cycle.
var target = {}
var proto = Object.create(target)
Reflect.setPrototypeOf(target, proto) // false
```

> 注意
>
> 对于以上所有 API 第一个参数是 Object 的，如果给定的不是 Object 则抛出一个 TypeError 异常

# Promise

## 异步操作前置知识

### JS是单线程的

就是同一个时间只能处理一个任务。就类似生活中的去超市排队结账，正常情况下，一位收银员只能为一位顾客结账，其他顾客需要在后面排队等候。

为什么 JS 是单线程的？作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM 。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

单线程就意味着，所有任务都需要排队，前一个任务结束，才能执行后一个任务。如果前一个任务耗时很长，那么后一个任务就不得不一直等待，于是乎，JS 设计者们把所有任分成两类，同步和异步。

- 同步：只有前一个任务执行完毕，才能执行后一个任务
- 异步：当同步任务执行到某个 WebAPI 时，就会触发异步操作，此时浏览器会单独开线程去处理这些异步任务。

```js
 // 同步
 const a = 2
 const b = 3
 console.log(a + b)

 // 异步
 setTimeout(() => {
     console.log(a + b)
 }, 1000)
```

请思考下面的输出结果是什么？

```js
console.log(1)
setTimeout(() => { // 异步任务，放入任务队列中
    console.log(2)
}, 0)
console.log(3)

// 1、3、2
```

下图说明了同步任务和异步任务的执行过程： ![img](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic@master/javaImg/task.9fef93a6.png)

### Ajax原理

Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。

```js
// 创建 XMLHttpRequest 对象
const url = 'http://jsonplaceholder.typicode.com/users'
let xmlhttp
if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
    xmlhttp = new XMLHttpRequest()
} else { // code for IE6, IE5
    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP")
}

// 发送请求
xmlhttp.open("GET", url, true)
xmlhttp.send()

// 服务端响应
xmlhttp.onreadystatechange = function() {
    if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
        //    console.log(xmlhttp.responseText)
        let obj = JSON.parse(xmlhttp.responseText)
        console.log(obj)
    }
}
```

### Callback Hell

JavaScipt 中的许多操作都是异步的，我们把上面的Ajax封装成一个函数：

```js
function ajax(url, callback) {
    let xmlhttp
    if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
        xmlhttp = new XMLHttpRequest()
    } else { // code for IE6, IE5
        xmlhttp = new ActiveXObject("Microsoft.XMLHTTP")
    }
    // 发送请求
    xmlhttp.open("GET", url, true)
    xmlhttp.send()
    // 服务端响应
    xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
            //    console.log(xmlhttp.responseText)
            let obj = JSON.parse(xmlhttp.responseText)
            callback(obj)
        }
    }
}
```

我们在static文件夹下放入三个json文件：

a.json:

```json
{
    "a": "我是A"
}
```

b.json:

```json
{
    "b": "我是B"
}
```

c.json:

```json
{
    "c": "我是C"
}
```

我们可以像这样使用：

```js
// 加载并执行脚本
ajax('/static/a.json')
```

函数是异步调用的，因为操作不是立即完成的，而是之后才会完成。

```js
ajax('/static/a.json')
// 下面的代码不会等到ajax执行完才执行
// ...
```

这个过程大家并不陌生，可是如果在回调之后再回调呢？

```js
ajax('static/a.json', res => {
    console.log(res)
    ajax('static/b.json', res => {
        console.log(res)
        ajax('static/c.json', res => {
            console.log(res)
        })
    })
})
```

如果嵌套变多，代码层次就会变深，维护难度也随之增加。

这就被称为 “回调地狱” 或者“回调深渊”。

## 基本语法

Promise 就是为了解决“回调地狱”问题的，它可以将异步操作的处理变得很优雅。回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象promise可以支持多个并发的请求，获取并发请求中的数据这个promise可以解决异步的问题，本身不能说promise是异步的。

创建Promise实例。

```js
const promise = new Promise(function(resolve, reject) {
    // ... some code

    if ( /* 异步操作成功 */ ) {
        resolve(value)
    } else {
        reject(error)
    }
})
```

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。

- 处理结果正常的话，调用resolve(处理结果值)，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
- 处理结果错误的话，调用reject(Error对象)，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。

```js
promise.then(function(value) {
    // success
}, function(error) {
    // failure
})
```

TIP

实际上 Promise 用起来还是比较简单的，是不是可以动手试一试去封装自己业务中应用到的异步操作了（之前用回调写的）？

在这里必须说明下 Promise 内部是有状态的(pending、fulfilled、rejected)，Promise 对象根据状态来确定执行哪个方法。Promise 在实例化的时候状态是默认 pending 的，当异步操作是完成的，状态会被修改为 fulfilled，如果异步操作遇到异常，状态会被修改为 rejected，可以通过下图来看下状态的走向：

![img](https://cdn.jsdelivr.net/gh/MaiRen1997/mdPic@master/javaImg/promise.04ed9cc2.png)

> 注意
>
> 状态转化是单向的，不可逆转，已经确定的状态（fulfilled/rejected）无法转回初始状态（pending），而且只能是从 pending 到 fulfilled 或者 rejected

## Promise.prototype.then()

**基本语法**

> promise.then(onFulfilled, onRejected)

**示例**

```js
var promise = new Promise(function(resolve, reject) {
    resolve('传递给then的值')
})
promise.then(function(value) {
    console.log(value)
}, function(error) {
    console.error(error)
})
```

这段代码创建一个 Promise 对象，定义了处理 onFulfilled 和 onRejected 的函数（handler），然后返回这个 Promise 对象。

这个 Promise 对象会在变为 resolve 或者 reject 的时候分别调用相应注册的回调函数。

- 当 handler 返回一个正常值的时候，这个值会传递给 Promise 对象的 onFulfilled 方法。
- 定义的 handler 中产生异常的时候，这个值则会传递给 Promise 对象的 onRejected 方法。

## Promise.prototype.catch()

捕获异常是程序质量保障最基本的要求，可以使用 Promise 对象的 catch 方法来捕获异步操作过程中出现的任何异常。

**基本语法**

> p.catch(onRejected)

> p.catch(function(reason) {

// rejection })

**示例**

```js
function test() {
    return new Promise((resolve, reject) => {
        reject(new Error('es'))
    })
}

test().catch((e) => {
    console.log(e.message) // es
})
```

这个代码展示了如何使用 catch 捕获 Promise 对象中的异常，有的同学会问 catch 捕获的是 Promise 内部的 Error 还是 Reject？上面的示例既用了 reject 也用了 Error，到底是哪个触发的这个捕获呢？

```js
function test() {
    return new Promise((resolve, reject) => {
        throw new Error('wrong')
    })
}

test().catch((e) => {
    console.log(e.message) // wrong
})
```

这个代码对比着上个代码就能明显感受出来的，throw Error 和 reject 都触发了 catch 的捕获，而第一个用法中虽然也有 Error 但是它不是 throw，只是 reject 的参数是 Error 对象，换句话说 new Error 不会触发 catch，而是 reject。

> 注意
>
> 不建议在 Promise 内部使用 throw 来触发异常，而是使用 `reject(new Error())` 的方式来做，因为 throw 的方式并没有改变 Pronise 的状态

## Promise.resolve()

一般情况下我们都会使用 ```new Promise()` ``来创建 Promise 对象，但是除此之外我们也可以使用其他方法。

在这里，我们将会学习如何使用 Promise.resolve 和 Promise.reject 这两个方法。

静态方法 Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。

比如 Promise.resolve(42) 可以认为是以下代码的语法糖。

```js
new Promise(function(resolve) {
    resolve(42)
})
```

在这段代码中的 resolve(42) 会让这个 Promise 对象立即进入确定（即resolved）状态，并将 42 传递给后面 then 里所指定的 onFulfilled 函数。

方法 Promise.resolve(value) 的返回值也是一个 Promise 对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。

```js
Promise.resolve(42).then(function(value) {
    console.log(value)
})
```

Promise.resolve 作为 new Promise() 的快捷方式，在进行 Promise 对象的初始化或者编写测试代码的时候都非常方便。

## Promise.reject()

Promise.reject(error) 是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。

比如 Promise.reject(new Error("出错了")) 就是下面代码的语法糖形式。

```js
new Promise(function(resolve, reject) {
    reject(new Error('出错了'))
})
```

这段代码的功能是调用该Promise 对象通过then指定的 onRejected 函数，并将错误（Error）对象传递给这个 onRejected 函数。

```js
Promise.reject(new Error('BOOM!'))
```

## Promise.all()

**基本语法**

> Promise.all(promiseArray)

**示例**

```js
var p1 = Promise.resolve(1)
var p2 = Promise.resolve(2)
var p3 = Promise.resolve(3)
Promise.all([p1, p2, p3]).then(function(results) {
    console.log(results) // [1, 2, 3]
})
```

Promise.all 生成并返回一个新的 Promise 对象，所以它可以使用 Promise 实例的所有方法。参数传递promise数组中所有的 Promise 对象都变为resolve的时候，该方法才会返回， 新创建的 Promise 则会使用这些 promise 的值。

如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的 Promise 对象。

由于参数数组中的每个元素都是由 Promise.resolve 包装（wrap）的，所以Promise.all 可以处理不同类型的 Promise 对象。

## Promise.race()

**基本语法**

> Promise.race(promiseArray)

**示例**

```js
var p1 = Promise.resolve(1)
var p2 = Promise.resolve(2)
var p3 = Promise.resolve(3)
Promise.race([p1, p2, p3]).then(function(value) {
    console.log(value) // 1
})
```

Promise.race 生成并返回一个新的 Promise 对象。

参数 promise 数组中的任何一个 Promise 对象如果变为 resolve 或者 reject 的话， 该函数就会返回，并使用这个 Promise 对象的值进行 resolve 或者 reject。

## 练习

如何把前面Callback Hell的代码改写成promise的写法呢？

```js
function getPromise(url) {
    return new Promise((resolve, reject) => {
        ajax(url, res => {
            resolve(res)
        }, err => {
            reject(err)
        })
    })
}

getPromise('static/a.json')
    .then(res => {
        console.log(res)
        return getPromise('static/b.json')
    }).then(res => {
        console.log(res)
        return getPromise('static/c.json')
    }).then(res => {
        console.log(res)
    }).catch(err => {
        console.log(err)
    })
```

# Generator

什么是 JavaScript Generators 呢？通俗的讲 Generators 是可以用来控制迭代器的函数。它们可以暂停，然后在任何时候恢复。如果这句话不好理解，可以看下接下来的示例。

**1. 常规循环**

```js
for (let i = 0; i < 5; i += 1) {
    console.log(i)
}
// this will return immediately 0 -> 1 -> 2 -> 3 -> 4
```

**2. 利用 Generator**

```js
function* generatorForLoop() {
    for (let i = 0; i < 5; i += 1) {
        yield console.log(i)
    }
}

const genForLoop = generatorForLoop()

console.log(genForLoop.next()) // first console.log - 0
console.log(genForLoop.next()) // 1
console.log(genForLoop.next()) // 2
console.log(genForLoop.next()) // 3
console.log(genForLoop.next()) // 4
```

对比下代码，常规的循环只能一次遍历完所有值，Generator 可以通过调用 next 方法拿到依次遍历的值，让遍历的执行变得“可控”。

## 基本语法

### 定义

```js
function* gen() {
    yield 1
    yield 2
    yield 3
}

let g = gen()
// "Generator { }"
```

这个是 Generator 的定义方法，有几个点值得注意：

1. 比普通函数多一个 *
2. 函数内部用 yield 来控制程序的执行的“暂停”
3. 函数的返回值通过调用 next 来“恢复”程序执行

注意

Generator 函数的定义不能使用箭头函数，否则会触发 SyntaxError 错误

```js
let generator = * () => {} // SyntaxError
let generator = () * => {} // SyntaxError
let generator = ( * ) => {} // SyntaxError
```

这些做法都是错误的❌。

### yield 表达式

> yield 关键字用来暂停和恢复一个生成器函数

关于 yield 表达式，要熟记几个知识点：

1. yield 表达式的返回值是 undefined，但是遍历器对象的 next 方法可以修改这个默认值。

```js
  function* gen() {
      let val
      val = yield 1
      console.log( `1:${val}` ) // 1:undefined
      val = yield 2
      console.log( `2:${val}` ) // 2:undefined
      val = yield 3
      console.log( `3:${val}` ) // 3:undefined
  }

  var g = gen()

  console.log(g.next()) // {value: 1, done: false}
  console.log(g.next()) // {value: 2, done: false}
  console.log(g.next()) // {value: 3, done: false}
  console.log(g.next()) // {value: undefined, done: true}
```

从这个代码可以看出来，yield 表达式的返回值是 undefined。

1. **yeild **是委托给另一个遍历器对象或者可遍历对象

```js
  function* gen() {
      let val
      val = yield 1
      console.log( `1:${val}` ) // 1:undefined
      val = yield 2
      console.log( `2:${val}` ) // 2:undefined
      val = yield [3, 4, 5]
      console.log( `3:${val}` ) // 3:undefined
  }
```

1. Generator 对象的 next 方法，遇到 yield 就暂停，并返回一个对象，这个对象包括两个属性：value 和 done。

参考步骤1 的代码可以明确看出来，执行第一句 ```g.next` ``gen 代码执行到 yield 1，程序暂停，此时返回了一个对象：{value: 1, done: false}

### 方法

Generator 对象有几个方法，next、return、throw。

**- next([value])**

前面我们讲了，Generator 对象通过 next 方法来获取每一次遍历的结果，这个方法返回一个对象，这个对象包含两个属性：value 和 done。value 是指当前程序的运行结果，done 表示遍历是否结束。

其实 next 是可以接受参数的，这个参数可以让你在 Generator 外部给内部传递数据，而这个参数就是作为 yield 的返回值。

```js
  function* gen() {
      var val = 100
      while (true) {
          console.log( `before ${val}` )
          val = yield val
          console.log( `return ${val}` )
      }
  }

  var g = gen()
  console.log(g.next(20).value)
  // before 100
  // 100
  console.log(g.next(30).value)
  // return 30
  // before 30
  // 30
  console.log(g.next(40).value)
  // return 40
  // before 40
  // 40
```

如果对上面的话和代码不理解，可以把 ```console.log(g.next(30).value)` ``和 ```console.log(g.next(40).value)` ``注释掉。你会发现 只输出了 before 100 和 100，这是为什么呢？下面我们来还原下这段代码的执行过程：

1. g.next(20) 这句代码会执行 gen 内部的代码，遇到第一个 yield 暂停。所以 ```console.log(` before ${val} `)` ``执行输出了 ```before 100` ``，此时的 val 是 100，所以执行到 yield val 返回了 100，注意 ```yield val` ``并没有赋值给 val。
2. g.next(30) 这句代码会继续执行 gen 内部的代码，也就是 ```val = yield val` ``这句，因为 next 传入了 30，所以 yield val 这个返回值就是 30，因此 val 被赋值 30，执行到 ```console.log(` return ${val} `)` ``输出了 30，此时没有遇到 yield 代码继续执行，也就是 while 的判断，继续执行 ```console.log(` before ${val} `)` ``输出了 ```before 30` ``，再执行遇到了 ```yield val` ``程序暂停。
3. g.next(40) 重复步骤 2。

**- return()**

return 方法可以让 Generator 遍历终止，有点类似 for 循环的 break。

```js
function* gen() {
    yield 1
    yield 2
    yield 3
}

var g = gen()

console.log(g.next()) // {value: 1, done: false}
console.log(g.return()) // {value: undefined, done: true}
console.log(g.next()) // {value: undefined, done: true}
```

从 done 可以看出代码执行已经结束。

当然 return 也可以传入参数，作为返回的 value 值。

```js
function* gen() {
    yield 1
    yield 2
    yield 3
}

var g = gen()

console.log(g.next()) // {value: 1, done: false}
console.log(g.return(100)) // {value: 100, done: true}
console.log(g.next()) // {value: undefined, done: true}
```

**- throw()**

可以通过 throw 方法在 Generator 外部控制内部执行的“终断”。

```js
function* gen() {
    while (true) {
        try {
            yield 42
        } catch (e) {
            console.log(e.message)
        }
    }
}

let g = gen()
console.log(g.next()) // { value: 42, done: false }
console.log(g.next()) // { value: 42, done: false }
console.log(g.next()) // { value: 42, done: false }
// 中断操作
g.throw(new Error('break'))

console.log(g.next()) // {value: undefined, done: true}
```

> TIP
>
> 如果想退出遍历 catch 之后可以配合 ```return false` ``使用，能起到 “break” 的作用

## 应用场景

### 场景1

还是前面的异步操作，按顺序读取a.json、b.json、c.json，如果使用Generator该如何实现呢？

```js
function request(url) {
    ajax(url, res => {
        getData.next(res)
    })
}

function* gen() {
    let res1 = yield request('static/a.json')
    console.log(res1)
    let res2 = yield request('static/b.json')
    console.log(res2)
    let res3 = yield request('static/c.json')
    console.log(res3)
}
let getData = gen()
getData.next()
```

### 场景2

我们经常玩一些小游戏，比如数数字，敲7，到7和7的倍数，无限循环转圈去数数

```js
function* count(x = 1) {
    while (true) {
        if (x % 7 === 0) {
            yield x
        }
        x++
    }
}
// es5中就是个死循环 因为es5的循环需要有个终止值，但我们这个需求没有终止，一直在数数
let n = count()
console.log(n.next().value)
console.log(n.next().value)
console.log(n.next().value)
console.log(n.next().value)
console.log(n.next().value)
console.log(n.next().value)
```

# Iterator

> 处理集合中的每个项是很常见的操作。JavaScript 提供了许多迭代集合的方法，从简单的for循环到map()和filter()。迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义for...of循环的行为。

如果对 MDN 这个描述理解不是很到位的话，可以看下接下来这个小示例：

```js
let authors = {
    allAuthors: {
        fiction: [
            'Agatha Christie',
            'J. K. Rowling',
            'Dr. Seuss'
        ],
        scienceFiction: [
            'Neal Stephenson',
            'Arthur Clarke',
            'Isaac Asimov',
            'Robert Heinlein'
        ],
        fantasy: [
            'J. R. R. Tolkien',
            'J. K. Rowling',
            'Terry Pratchett'
        ]
    }
}
```

这个数据结构是汇总了所有作者，每个作者按创作性质进行了分类。如果我们想获取所有作者的名单，该怎么做呢？

```js
for (let author of authors) {
    console.log(author)
}
```

> 警告
>
> 你发现这个遍历遇到了报错：Uncaught TypeError: authors is not iterable

有的同学会说可以这样做：

```js
for (let key in authors) {
    let r = []
    for (let k in authors[key]) {
        r = r.concat(authors[key][k])
    }
    console.log(r)
    // ["Agatha Christie", "J. K. Rowling", "Dr. Seuss", "Neal Stephenson", "Arthur Clarke", "Isaac Asimov", "Robert Heinlein", "J. R. R. Tolkien", "J. K. Rowling", "Terry Pratchett"]
}
```

这个做法确实可以，实际上也是手动实现的遍历加数据合并，这其实不算是遍历。这个小节就是讲述如何给这种自定义的数据结构进行遍历

## 基本语法

Iterator 就是 ES6 中用来实现自定义遍历的接口，按照上述的示例，我们来实现下这个接口：

```js
authors[Symbol.iterator] = function() {
    let allAuthors = this.allAuthors
    let keys = Reflect.ownKeys(allAuthors)
    let values = []
    return {
        next() {
            if (!values.length) {
                if (keys.length) {
                    values = allAuthors[keys[0]]
                    keys.shift()
                }
            }
            return {
                done: !values.length,
                value: values.shift()
            }
        }
    }
}
```

这个代码在数据结构上部署了 Iterator 接口，我们就可以用 for...of 来遍历代码了：

```js
for (let value of authors) {
    console.log( `${value}` )
}
```

从代码上我们看到了自定义遍历器的强大，但是我们怎么理解 Iterator 呢？首先，要理解几个概念：可迭代协议和迭代器协议。

**1. 迭代器协议**

| 属性 |                              值                              | 必选 |
| :--: | :----------------------------------------------------------: | :--: |
| next | 返回一个对象的无参函数，被返回对象拥有两个属性：done 和 value |  Y   |

这是两个概念：可迭代协议、迭代器协议。通俗的讲，迭代器协议要求符合以下条件：

- 首先，它是一个对象
- 其次，这个对象包含一个无参函数 next
- 最后，next 返回一个对象，对象包含 done 和 value 属性。其中 done 表示遍历是否结束，value 返回当前遍历的值。

> 警告
>
> 如果 next 函数返回一个非对象值（比如false和undefined) 会展示一个 TypeError ("iterator.next() returned a non-object value") 的错误

**2. 可迭代协议**

可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为, 例如（定义）在一个 for..of 结构中什么值可以被循环（得到）。一些内置类型都是内置的可迭代类型并且有默认的迭代行为, 比如 Array or Map, 另一些类型则不是 (比如Object) 。

为了变成可迭代对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链 prototype chain 上的某个对象）必须有一个名字是 Symbol.iterator 的属性:

|       属性        |                        值                        | 必选 |
| :---------------: | :----------------------------------------------: | :--: |
| [Symbol.iterator] | 返回一个对象的无参函数，被返回对象符合迭代器协议 |  Y   |

如果让一个对象是可遍历的，就要遵守可迭代协议，该协议要求对象要部署一个以 Symbol.iterator 为 key 的键值对，而 value 就是一个无参函数，这个函数返回的对象要遵守迭代器协议。

## Generator

熟悉了 Generator 之后，发现它是天然满足可迭代协议的。上述的代码我们可以用 Generator 来实现：

```js
authors[Symbol.iterator] = function*() {
    let allAuthors = this.allAuthors
    let keys = Reflect.ownKeys(allAuthors)
    let values = []
    while (1) {
        if (!values.length) {
            if (keys.length) {
                values = allAuthors[keys[0]]
                keys.shift()
                yield values.shift()
            } else {
                return false
            }
        } else {
            yield values.shift()
        }
    }
}
```

同一个场景，同一个数据结构，写法确实不同的，利用 Generator 就不再需要显示的写迭代协议了（next方法和包含 done、value 属性的返回对象）

# Module

## 模块化的发展

技术的诞生是为了解决某个问题，模块化也是。 随着前端的发展，web技术日趋成熟，js功能越来越多，代码量也越来越大。之前一个项目通常各个页面公用一个js，但是js逐渐拆分，项目中引入的js越来越多. 在js模块化诞生之前，开发者面临很多问题:

- 全局变量污染：各个文件的变量都是挂载到window对象上，污染全局变量。
- 变量重名：不同文件中的变量如果重名，后面的会覆盖前面的，造成程序运行错误。
- 文件依赖顺序：多个文件之间存在依赖关系，需要保证一定加载顺序问题严重。

模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程， 有多种属性，分别反映其内部特性。百度百科中，模块化的定义是： 模块化是一种处理复杂系统分解为更好的可管理模块的方式。 简单的说，把一个复杂的东西分解成多个甚至多层次的组成部分，以一种良好的机制管理起来，就可以认为是模块化。而对于软件开发来说，函数（过程）就是最常见也是最基本的模块之一。

我觉得用乐高积木来比喻模块化再好不过了。每个积木都是固定的颜色形状，想要组合积木必须使用积木凸起和凹陷的部分进行连接，最后多个积木累积成你想要的形状。

模块化其实是一种规范，一种约束，这种约束会大大提升开发效率。将每个js文件看作是一个模块，每个模块通过固定的方式引入，并且通过固定的方式向外暴露指定的内容。 按照js模块化的设想，一个个模块按照其依赖关系组合，最终插入到主程序中。

我们梳理一下模块化的发展情况：

无模块化-->CommonJS规范-->AMD规范-->CMD规范-->ES6模块化

1、CommonJS规范 Node中模块化规范

Commonjs的诞生给js模块化发展有了重要的启发，Commonjs非常受欢迎， 但是局限性很明显：Commonjs基于Node原生api在服务端可以实现模块同步加载， 但是仅仅局限于服务端，客户端如果同步加载依赖的话时间消耗非常大，所以需要一个 在客户端上基于Commonjs但是对于加载模块做改进的方案，于是AMD规范诞生了。

2、AMD规范, 异步模块定义, 允许指定回调函数，AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到所有依赖加载完成之后（前置依赖），这个回调函数才会运行。

3、CMD规范，同样是受到Commonjs的启发，国内（阿里）诞生了一个CMD（Common Module Definition）规范。该规范借鉴了Commonjs的规范与AMD规范，在两者基础上做了改进。

CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。

AMD 推崇依赖前置、提前执行 CMD推崇依赖就近、延迟执行。

4、 到了2015年，ES6规范中，终于将模块化纳入JavaScript标准，从此js模块化被官方扶正，也是未来js的标准. 在ES6中，我们可以使用 import 关键字引入模块，通过 exprot 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的， 但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。

## export

模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。

一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。

1. 导出变量或者常量

```js
  export const name = 'hello'
  export let addr = 'BeiJing City'
  export var list = [1, 2, 3]
```

或者

```js
  const name = 'hello'
  let addr = 'BeiJing City'
  var list = [1, 2, 3]
  export {
      name,
      addr,
      list
  }
```

1. 导出函数

```js
  export function say(content) {
      console.log(content)
  }
  export function run() {
      console.log('run')
  }
```

或者

```js
  const say = (content) => {
      console.log(content)
  }
  let run = () => {
      console.log('run')
  }
  export {
      say,
      run
  }
```

1. 导出 Object

```js
  export ({
      code: 0,
      message: 'success'
  })
```

或者

```js
  let data = {
      code: 0,
      message: 'success'
  }
  export {
      data
  }
```

1. 导出 Class

```js
  class Test {
      constructor() {
          this.id = 2
      }
  }
  export {
      Test
  }
```

或者

```js
  export class Test {
      constructor() {
          this.id = 2
      }
  }
```

## as

如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。

```js
  const name = 'hello'
  let addr = 'BeiJing City'
  var list = [1, 2, 3]
  export {
      name as cname,
      addr as caddr,
      list
  }
```

## export default

使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。

为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。

```js
  const name = 'hello'
  let addr = 'BeiJing City'
  var list = [1, 2, 3]
  export {
      name as cname,
      addr as caddr
  }
  export default list
```

## import

使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。

1. 直接导入

假设导出模块 A 是这样的：

```js
  const name = 'hello'
  let addr = 'BeiJing City'
  var list = [1, 2, 3]
  export {
      name as cname,
      addr as caddr
  }
  export default list
```

则导入：

```js
  import list, {
      cname,
      caddr
  } from A
```

1. 修改导入名称

```js
  import list, {
      cname as name,
      caddr
  } from A
```

1. 批量导入

```js
  import list, * as mod from A
  console.log(list)
  console.log(mod.cname)
  console.log(mod.caddr)
```





















