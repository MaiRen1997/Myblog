## 安装

```shell
# 安装
pip install ujson

# 或安装带C扩展的版本
pip install ujson[cpython]
```

## 基本使用

```python
import ujson
import json
import time

# 性能对比测试
data = {"name": "张三", "age": 30, "scores": [95, 88, 92]}

# ujson 编码
start = time.time()
for _ in range(10000):
    ujson.dumps(data)
print(f"ujson 编码: {time.time() - start:.4f}秒")

# 标准 json 编码
start = time.time()
for _ in range(10000):
    json.dumps(data)
print(f"json 编码: {time.time() - start:.4f}秒")
```

## 核心Api

### 序列化

#### 默认序列化

```python
import ujson

# 基本使用
data = {
    "name": "张三",
    "age": 30,
    "married": False,
    "children": None,
    "scores": [95, 88, 92],
    "address": {"city": "北京", "street": "长安街"}
}

# 默认序列化
json_str = ujson.dumps(data)
print(json_str)
# {"name":"\u5f20\u4e09","age":30,"married":false,"children":null,"scores":[95,88,92],"address":{"city":"\u5317\u4eac","street":"\u957f\u5b89\u8857"}}

```

#### 美化输出

```python
import ujson

# 基本使用
data = {
    "name": "张三",
    "age": 30,
    "married": False,
    "children": None,
    "scores": [95, 88, 92],
    "address": {"city": "北京", "street": "长安街"}
}
# 美化输出（缩进）
pretty_json = ujson.dumps(data, indent=2)
print(pretty_json)
```

### 反序列化(loads)

```python
import ujson

# JSON字符串
json_str = '{"name": "李四", "age": 25, "active": true}'

# 解析为Python对象
data = ujson.loads(json_str)
print(data)          # {'name': '李四', 'age': 25, 'active': True}
print(type(data))    # <class 'dict'>
print(data['name'])  # 李四
```

### 序列化到文件

```python
import ujson

data = {
    "users": [
        {"id": 1, "name": "Alice", "email": "alice@example.com"},
        {"id": 2, "name": "Bob", "email": "bob@example.com"}
    ]
}

# 写入文件
with open('data.json', 'w', encoding='utf-8') as f:
    ujson.dump(data, f)

# 使用选项
with open('data_pretty.json', 'w', encoding='utf-8') as f:
    ujson.dump(data, f, indent=4, ensure_ascii=False)  # 保持中文字符
```

### 从文件反序列化

```python
import ujson

# 从文件读取
with open('data.json', 'r', encoding='utf-8') as f:
    loaded_data = ujson.load(f)

print(loaded_data)
print(f"用户数: {len(loaded_data['users'])}")
```

## 高级选项和参数

### 编码选项（`ujson.dumps()`/`ujson.dump()`）

```python
import ujson
import decimal
import datetime

data = {
    "name": "张三",
    "score": 95.5,
    "timestamp": datetime.datetime.now()
}

# 1. ensure_ascii - 是否转义非ASCII字符
print(ujson.dumps(data, ensure_ascii=True))   # 转义中文字符
print(ujson.dumps(data, ensure_ascii=False))  # 保留中文字符

# 2. encode_html_chars - 编码HTML特殊字符
html_data = {"text": "<script>alert('xss')</script>"}
print(ujson.dumps(html_data, encode_html_chars=True))
# {"text":"\u003cscript\u003ealert('xss')\u003c/script\u003e"}

# 3. escape_forward_slashes - 是否转义正斜杠
url_data = {"url": "https://example.com/path/to/file"}
print(ujson.dumps(url_data, escape_forward_slashes=False))
print(ujson.dumps(url_data, escape_forward_slashes=True))

# 4. sort_keys - 按键排序
unsorted = {"b": 2, "a": 1, "c": 3}
print(ujson.dumps(unsorted, sort_keys=True))  # {"a":1,"b":2,"c":3}

# 5. indent - 缩进美化
print(ujson.dumps(data, indent=2))

# 6. 处理特殊类型（需要自定义编码）
class CustomEncoder:
    def default(self, obj):
        if isinstance(obj, datetime.datetime):
            return obj.isoformat()
        elif isinstance(obj, decimal.Decimal):
            return float(obj)
        raise TypeError(f"Object of type {type(obj)} is not JSON serializable")

# ujson 不支持自定义编码器，需先转换
data_fixed = {
    "name": "张三",
    "score": float(decimal.Decimal("95.5")),
    "timestamp": datetime.datetime.now().isoformat()
}
```

### 解码选项（`ujson.loads()`/`ujson.load()`）

```python
import ujson

# 1. 精确浮点数解析
json_str = '{"price": 12.345678901234567}'
data = ujson.loads(json_str)
print(data)  # {'price': 12.345678901234567}

# 2. 处理大数据
large_json = '[' + ','.join(['{"id": ' + str(i) + '}' for i in range(10000)]) + ']'
data = ujson.loads(large_json)  # 快速解析大量数据
print(f"解析了 {len(data)} 条记录")

# 3. 解析时检查
try:
    invalid_json = "{'name': '张三'}"  # JSON必须使用双引号
    data = ujson.loads(invalid_json)
except ujson.JSONDecodeError as e:
    print(f"JSON解析错误: {e}")
    print(f"位置: {e.pos}")
    print(f"文档: {e.doc}")
```

## 性能优化技巧

### 批量处理大量数据

```python
import ujson
import time

# 生成测试数据
records = [{"id": i, "value": f"data_{i}", "score": i * 0.5} for i in range(100000)]

# 方法1：分别编码（慢）
start = time.time()
json_strings = []
for record in records:
    json_strings.append(ujson.dumps(record))
print(f"分别编码: {time.time() - start:.3f}秒")

# 方法2：批量编码（快）
start = time.time()
bulk_json = ujson.dumps(records)  # 编码整个列表
print(f"批量编码: {time.time() - start:.3f}秒")

# 批量解码
start = time.time()
decoded = ujson.loads(bulk_json)
print(f"批量解码: {time.time() - start:.3f}秒")
```

### 使用预分配列表

```python
import ujson
import ijson  # 对于超大文件，可以使用ijson流式解析

def process_large_json_stream(filepath):
    """流式处理超大JSON文件"""
    with open(filepath, 'r', encoding='utf-8') as f:
        # ujson不支持流式解析，但可以逐行处理
        buffer = []
        for line in f:
            if line.strip():
                try:
                    # 假设每行是一个JSON对象
                    obj = ujson.loads(line)
                    buffer.append(obj)
                    
                    # 批量处理
                    if len(buffer) >= 1000:
                        process_batch(buffer)
                        buffer = []
                except ujson.JSONDecodeError:
                    continue
        # 处理剩余数据
        if buffer:
            process_batch(buffer)
```

## 与标准json模块的兼容性

```python
import ujson
import json

class UJSONEncoder:
    """兼容标准json接口的包装器"""
    
    @staticmethod
    def dumps(obj, **kwargs):
        # 转换标准json参数到ujson参数
        ujson_kwargs = {}
        
        # 参数映射
        if 'ensure_ascii' in kwargs:
            ujson_kwargs['ensure_ascii'] = kwargs['ensure_ascii']
        if 'indent' in kwargs:
            ujson_kwargs['indent'] = kwargs['indent']
        if 'sort_keys' in kwargs:
            ujson_kwargs['sort_keys'] = kwargs['sort_keys']
            
        return ujson.dumps(obj, **ujson_kwargs)
    
    @staticmethod
    def loads(s, **kwargs):
        return ujson.loads(s)

# 使用兼容接口
data = {"name": "张三", "age": 30}

# 像使用标准json一样使用
json_str = UJSONEncoder.dumps(data, ensure_ascii=False, indent=2)
print(json_str)

parsed = UJSONEncoder.loads(json_str)
print(parsed)
```

## 实际应用示例

### Web API 数据处理

```python
import ujson
import requests

class FastJSONAPI:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        
    def get_users(self):
        """获取用户列表（快速解析）"""
        response = self.session.get(f"{self.base_url}/users")
        
        # 使用ujson快速解析
        try:
            return ujson.loads(response.text)
        except ujson.JSONDecodeError:
            # 降级到标准json
            import json
            return json.loads(response.text)
    
    def post_data(self, data):
        """发送数据（快速序列化）"""
        # 使用ujson快速序列化
        json_data = ujson.dumps(data, ensure_ascii=False)
        
        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        
        response = self.session.post(
            f"{self.base_url}/data",
            data=json_data,
            headers=headers
        )
        
        return ujson.loads(response.text)
```

### 日志数据快速处理

```python
import ujson
import time
from typing import List, Dict

class FastLogger:
    def __init__(self, log_file: str):
        self.log_file = log_file
        
    def write_log(self, level: str, message: str, **extra):
        """写入结构化日志"""
        log_entry = {
            "timestamp": time.time(),
            "level": level,
            "message": message,
            **extra
        }
        
        # 快速序列化
        json_line = ujson.dumps(log_entry, ensure_ascii=False)
        
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(json_line + '\n')
    
    def read_logs(self, limit: int = 100) -> List[Dict]:
        """快速读取日志"""
        logs = []
        try:
            with open(self.log_file, 'r', encoding='utf-8') as f:
                for i, line in enumerate(f):
                    if i >= limit:
                        break
                    if line.strip():
                        logs.append(ujson.loads(line))
        except FileNotFoundError:
            pass
        return logs

# 使用
logger = FastLogger('app.log')
logger.write_log("INFO", "用户登录", user_id=123, ip="192.168.1.1")
logs = logger.read_logs(10)
```

### 配置管理

```python
import ujson
import os
from typing import Any, Optional

class ConfigManager:
    def __init__(self, config_file: str = 'config.json'):
        self.config_file = config_file
        self._config = {}
        self.load()
    
    def load(self):
        """加载配置（快速解析）"""
        if os.path.exists(self.config_file):
            with open(self.config_file, 'r', encoding='utf-8') as f:
                self._config = ujson.load(f)
        else:
            self._config = {}
    
    def save(self):
        """保存配置（快速序列化）"""
        with open(self.config_file, 'w', encoding='utf-8') as f:
            ujson.dump(self._config, f, indent=2, ensure_ascii=False)
    
    def get(self, key: str, default: Any = None) -> Any:
        """获取配置值"""
        return self._config.get(key, default)
    
    def set(self, key: str, value: Any):
        """设置配置值"""
        self._config[key] = value
        self.save()

# 使用
config = ConfigManager()
config.set("database.host", "localhost")
config.set("database.port", 3306)

host = config.get("database.host")
print(f"数据库主机: {host}")
```

### 错误处理和调试

```python
import ujson
import traceback

def safe_json_parse(json_str: str, fallback=None):
    """安全的JSON解析"""
    try:
        return ujson.loads(json_str)
    except ujson.JSONDecodeError as e:
        print(f"JSON解析错误: {e}")
        print(f"错误位置: {e.pos}")
        
        # 显示错误附近的上下文
        start = max(0, e.pos - 20)
        end = min(len(json_str), e.pos + 20)
        context = json_str[start:end]
        print(f"错误上下文: ...{context}...")
        
        return fallback

# 测试
test_cases = [
    '{"name": "张三"}',  # 有效
    '{name: "张三"}',    # 无效（缺少引号）
    '{"name": "张三"',   # 无效（缺少闭合）
    '[1, 2, 3]',        # 有效
]

for test in test_cases:
    result = safe_json_parse(test, fallback={"error": "解析失败"})
    print(f"输入: {test[:30]}... -> 结果: {result}")
```

## 性能测试和对比

```python
import ujson
import json
import time
import random
import string

def generate_test_data(num_records=1000):
    """生成测试数据"""
    data = []
    for i in range(num_records):
        record = {
            "id": i,
            "name": ''.join(random.choices(string.ascii_letters, k=10)),
            "email": f"user{i}@example.com",
            "age": random.randint(18, 65),
            "score": random.random() * 100,
            "active": random.choice([True, False]),
            "tags": random.choices(["python", "java", "js", "go"], k=3),
            "metadata": {
                "created": time.time(),
                "updated": time.time() + random.randint(0, 1000)
            }
        }
        data.append(record)
    return data

def benchmark():
    """性能基准测试"""
    data = generate_test_data(5000)
    
    print("性能基准测试 (5000条记录)")
    print("=" * 50)
    
    # 序列化测试
    start = time.time()
    json_str_ujson = ujson.dumps(data)
    ujson_dump_time = time.time() - start
    
    start = time.time()
    json_str_json = json.dumps(data)
    json_dump_time = time.time() - start
    
    print(f"序列化速度:")
    print(f"  ujson: {ujson_dump_time:.4f}秒 (快{json_dump_time/ujson_dump_time:.1f}倍)")
    print(f"  json:  {json_dump_time:.4f}秒")
    
    # 反序列化测试
    start = time.time()
    ujson.loads(json_str_ujson)
    ujson_load_time = time.time() - start
    
    start = time.time()
    json.loads(json_str_json)
    json_load_time = time.time() - start
    
    print(f"\n反序列化速度:")
    print(f"  ujson: {ujson_load_time:.4f}秒 (快{json_load_time/ujson_load_time:.1f}倍)")
    print(f"  json:  {json_load_time:.4f}秒")
    
    # 文件I/O测试
    print(f"\n文件I/O测试:")
    
    # ujson写入
    start = time.time()
    with open('test_ujson.json', 'w', encoding='utf-8') as f:
        ujson.dump(data, f)
    ujson_write_time = time.time() - start
    
    # json写入
    start = time.time()
    with open('test_json.json', 'w', encoding='utf-8') as f:
        json.dump(data, f)
    json_write_time = time.time() - start
    
    print(f"  写入文件:")
    print(f"    ujson: {ujson_write_time:.4f}秒")
    print(f"    json:  {json_write_time:.4f}秒")
    
    # 清理
    import os
    os.remove('test_ujson.json')
    os.remove('test_json.json')

if __name__ == "__main__":
    benchmark()
```















































