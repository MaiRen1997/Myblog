---
title: super深入了解
date: 2025-05-07 14:00:06
permalink: /pages/32f03a/
categories:
  - 后端
  - Python学习
  - 面向对象编程
tags:
  - 
author: 
  name: Riverside Joy
  link: https://github.com/MaiRen1997
---
## super

### 简单举例

**super是严格按照类的继承顺序执行！！！**

```python
class A:
    def f1(self):
        print('in A f1')
    
    def f2(self):
        print('in A f2')


class Foo(A):
    def f1(self):
        super().f2()
        print('in A Foo')
        
        
obj = Foo()
obj.f1()

super可以下一个类的其他方法
```

### MRO代码解析

1. MRO顺序： [Info, Foo, Bar, A, object]
2. 流程分析
   1. 先执行Info的f1方法， 
      1. 遇到super和print, 先执行super().f1()
      2. 发现没有执行完，继续递归调用(跳转到下面的第二条)
      3. print先不执行
   2. 根据MRO顺序，INFO的下一个类是Bar，所以执行Bar的f1方法
      1. 由于Bar的f1方法，没有super()方法，所以直接print
      2. 然后执行器交到上一层，也就是Info层
   3. Info层中的print得以执行，并打印数据
3. **`这个执行顺序，并不是按照继承层级往上走，而是按照MRO顺序执行的`**

```python
class A:
    def f1(self):
        print('in A') # 永远不会被执行

class Foo(A):
    def f1(self):
        super().f1()    # 2. 调用 MRO 中 Foo 的下一个类：Bar.f1()
        print('in Foo') # 3. Bar.f1() 返回后执行

class Bar(A):
    def f1(self):
        print('in Bar') # 3. 直接打印，没有 super()

class Info(Foo,Bar):
    def f1(self):
        super().f1()        # 1. 调用 MRO 中 Info 的下一个类：Foo.f1()
        print('in Info f1') # 4. 最后执行

obj = Info()
obj.f1()

'''
in Bar
in Foo
in Info f1
'''
print(Info.mro())  # [<class '__main__.Info'>, <class '__main__.Foo'>, <class '__main__.Bar'>, <class '__main__.A'>, <class 'object'>]

super()严格按照类的mro顺序执行
```

### 多层复合依赖

1. 对于多层复合依赖MRO：

   1. 一般都是先实例层，
   2. 然后往上一层的，多个依赖项
   3. 然后再往上一层的，多个依赖项

   而不是先找到上一层的A，然后再递归找A的依赖项，这是错误的观点

```python
class B:
  def f1(self):
    print('in B')

class C:
  def f1(self):
    print('in C')

class A(B,C):
  def f1(self):
    print('in A')

class Foo(A):
  def f1(self):
    super().f1()
    print('in Foo')


class Bar(A):
  def f1(self):
    super().f1()
    print('in Bar')


class Info(Foo, Bar):
  def f1(self):
    super().f1()
    print('in Info f1')

print(Info.mro()) #[<class '__main__.Info'>, <class '__main__.Foo'>, <class '__main__.Bar'>, <class '__main__.A'>, <class '__main__.B'>, <class '__main__.C'>, <class 'object'>]
```

### 改变super查找起点

#### 说明

1. 下面代码，在Info中使用了super(Foo,self).f1()， super中有参数，改变了super在MRO中的起点

#### 执行过程

1. super(Foo,self).f1() 的含义

   1. `self` 是 `Info` 实例

   2. `Foo` 是指定的起始查找类

   3. **从 MRO 中 `Foo` 的下一个类开始查找 `f1()` 方法，也就是调用了Bar的f1()方法**

   4. ```txt
      MRO: [Info, Foo, Bar, A, object]
              ↑     ↑    ↑
              跳过  起点 下一个
      
      super(Foo, self) → 从 Foo 之后开始：Bar
      ```

2. ```python
   class A:
       def f1(self):
           print('in A')
   
   class Foo(A):
       def f1(self):
           super().f1()
           print('in Foo')
   
   class Bar(A):
       def f1(self):
           print('in Bar')
   
   class Info(Foo,Bar):
       def f1(self):
           super(Foo,self).f1()
           print('in Info f1')
   
   obj = Info()
   obj.f1()
   print(Info.mro()) #[<class '__main__.Info'>, <class '__main__.Foo'>, <class '__main__.Bar'>, <class '__main__.A'>, <class 'object'>]
   '''
   in Bar
   in Info f1
   '''
   ```

